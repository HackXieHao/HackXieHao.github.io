<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python爬虫系列（一）：urllib使用中的问题]]></title>
    <url>%2F2019%2F01%2F10%2F2019-01-10-Python%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Aurllib%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Python爬虫系列（一）：urllib的使用及问题解决1 使用正则表达式匹配出现的问题代码如下： 12345678910111213141516171819202122232425262728from urllib import requestimport urllibimport redef download(url, user_agent = 'wswp', num_retries = 2): print("Downloading:",url) req = request.Request(url) req.add_header('User-Agent',user_agent) try: html = request.urlopen(req).read() # HTTPError才有code属性，URLError有reason属性 except urllib.error.HTTPError as e: html = None if(num_retries &gt; 0): if (hasattr(e,'code') and 500 &lt;= e.code &lt;= 600): #出现错误继续尝试 return download(url,user_agent,num_retries - 1) print(e.code) return htmldef crawl_sitemap(url): html = download(url) pattern = re.compile('&lt;loc&gt;(.*?)&lt;/loc&gt;') links = re.findall(pattern, html) for link in links: print(link)crawl_sitemap("http://example.webscraping.com/sitemap.xml") TypeError: cannot use a string pattern on a bytes-like object 原因：编码问题，正则表达式是一个Unicode字符串，而urlopen()返回来的类似文件对象的结果经过read()方法得到的是一个ASCII/bytes字符串。 解决方案： 将行 12342. 正则表达式编译的时候使用bytes，即 将```pattern = re.compile('&lt;loc&gt;(.*?)&lt;/loc&gt;')```改为```pattern = re.compile(b'&lt;loc&gt;(.*?)&lt;/loc&gt;') 若仅如此做，则在输出结果中会是一个字符串前面带一个b，因此还需要将结果转为字符串： 12for link in links: print(str(link,'utf-8')) 2 ID爬虫观察如下URL： 12345http://example.webscraping.com/places/default/view/Afghanistan-1http://example.webscraping.com/places/default/view/Aland-Islands-2http://example.webscraping.com/places/default/view/Albania-3http://example.webscraping.com/places/default/view/Algeria-4http://example.webscraping.com/places/default/view/American-Samoa-5 可以看出，这些URL仅在结尾处有区别，包括国家名（作为页面别名）和ID。在URL中包含页面别名是非常普遍的做法，可以对搜索引擎优化起到帮助作用。一般情况下，Web服务器会忽略这个字符串，只使用ID来匹配数据库中的相关记录。我们将其移除后使用12345678910111213141516171819**这里使用到itertools模块**```pythonimport itertoolsimport time# 指定最大错误次数max_errors = 5num_errors = 0for page in itertools.count(1): url = &apos;http://example.webscraping.com/places/default/view/&apos; + str(page) # print(url) html = download(url) print(html) time.sleep(2) if html is None: num_errors += 1 if(num_errors &gt;= max_errors): break 3 链接爬虫通过跟踪所有链接，可以访问整个网站的页面，通过模式匹配进行过滤，最终得到感兴趣的页面。 这里使用到urljoin 123456789101112131415161718192021222324252627282930from urllib.parse import urlparse,urljoindef link_crawl(seed_url, link_regex): ''' 链接爬虫，seed_url为原始url，link_regex为设置感兴趣的页面规则 ''' # 保存url的队列 crawl_queue = [seed_url] #已访问过的url url_seen = set(crawl_queue) while crawl_queue: url = crawl_queue.pop() html = download(url) for link in get_links(html): if re.match(link_regex, link): #类似于'/places/default/index'，通过urljoin得到绝对路径 link = urljoin(seed_url, link) #判断url是否已经访问过 if link not in url_seen: url_seen.add(link) crawl_queue.append(link)def get_links(html): ''' 从初始url返回的html页面中提取urls ''' webpage_regex = re.compile('&lt;a[^&gt;]+href=["\'](.*?)["\']', re.I) return webpage_regex.findall(html.decode('utf-8'))#字符串前带r防止转义link_crawl("http://example.webscraping.com", r'(.+)/(index|view)') 3.1 解析robots.txtpython3中使用urllib的robotparser，可以判断使用的用户代理是否可以访问url 1234567891011from urllib import robotparserrp = robotparser.RobotFileParser()rp.set_url('http://example.webscraping.com/robots.txt')rp.read()url = 'http://example.webscraping.com'user_agent = 'BadCrawler'#判断该代理是否可以访问urlprint(rp.can_fetch(user_agent, url)) # Falseuser_agent = 'GoodCrawler'print(rp.can_fetch(user_agent, url)) # True 12345678910111213141516![robots文件内容](/2019-01-10-Python爬虫系列（一）：urllib使用中的问题/001.png)#### 3.2 支持代理（IP）有时候我们需要使用代理访问某个网站，例如Netflix屏蔽了美国以外的大多数国家。这里使用urllib实现该功能（可以使用更友好的Python HTTP模块requests来实现该功能）：```pythonfrom urllib import requestproxy_handler = request.ProxyHandler(&#123;&apos;http&apos;: &apos; 192.168.173.1:80&apos;&#125;)# 付费代理写法#proxy = &#123;&quot;http&quot;:&quot;账号:密码@143.226.164.130:16816&quot;&#125;opener = request.build_opener(proxy_handler)response = opener.open(&apos;https://www.baidu.com&apos;)print(response.read()) 可以准备多个IP代理，随机访问： 123456789101112131415import randomproxy_list = [ &#123;"http" : "121.81.61.81:80"&#125;, &#123;"http" : "122.82.62.82:80"&#125;, &#123;"http" : "123.83.63.83:80"&#125;, &#123;"http" : "124.84.64.84:80"&#125;, &#123;"http" : "125.85.65.85:80"&#125;]# 随机选择一个代理proxy = random.choice(proxy_list)proxy_handler = request.ProxyHandler(proxy)opener = request.build_opener(proxy_handler)response = opener.open('https://www.baidu.com')print(response.read()) 下面使用requests模块实现： （1）普通代理 12345678910import requests# 根据协议类型，选择不同的代理proxies = &#123; "http": "http://192.168.173.1", "https": "http://192.168.173.1",&#125;response = requests.get("http://www.baidu.com", proxies = proxies)print(response.text) 这里若将访问的url改为123```pythonrequests.exceptions.ProxyError: HTTPSConnectionPool(host=&apos;www.baidu.com&apos;, port=443): Max retries exceeded with url: / (Caused by ProxyError(&apos;Cannot connect to proxy.&apos;, OSError(&apos;Tunnel connection failed: 400 Bad Request&apos;,))) 具体错误原因还没搞太清楚，但是值得注意的是访问https站点要用https类型的代理，访问http站点要用http类型的代理。 （2）私密代理 12345678import requests# 如果代理需要使用HTTP Basic Auth，可以使用下面这种格式：proxy = &#123; "http": "账号:密码@61.158.163.130:16816" &#125;response = requests.get("http://www.baidu.com", proxies = proxy)print(response.text) 3.3 下载限速当我们爬取网站速度过快时，容易被封禁或造成服务器过载。因此我们可以在两次下载之间设置延时： 12345678910111213141516171819202122from urllib.parse import urlparseimport datetimeimport timeclass Throttle(object): def __init__(self, delay): self.delay = delay self.domains = &#123;&#125; def wait(self, url): #获取服务器位置（用户信息） domain = urlparse(url).netloc last_accessed = self.domains.get(domain) # 如果当前时间距离上次访问时间小于延时，则执行睡眠操作 if self.delay &gt; 0 and last_accessed is not None: # datetime模块里面的datetime类的now函数 sleep_secs = self.delay - (datetime.datetime.now() - last_accessed).second if sleep_secs &gt; 0: time.sleep(sleep_secs) self.domains[domain] = datetime.datetime.now() 可以在每次下载之前调用Throttle对爬虫进行限速。大致代码如下： 123throttle = Throttle(delay)throttle.wait(url)result = download(url, headers, proxy = proxy, num_retries = num_retries) 3.4 避免爬虫陷阱有些网站会动态生成页面内容，从而导致出现无限多个网页。比如某网站有一个在线日历功能，提供访问下个月的链接，那么下个月的链接中同样也包含访问再下一个月的链接，这样页面就会无止境地链接下去。这种称之为爬虫陷阱。 解决方案：设置链接深度。 对链接爬虫进行改进： 123456789101112def link_crawler(..., max_depth): max_depth = 2 # 将已访问过的链接改为用dict保存，key为url，value为该url的访问深度 url_seen = &#123;&#125; ... depth = url_seen[url] if depth != max_depth: for link in links: if link not in url_seen: url_seen[link] = depth + 1 crawl_queue.append(link)]]></content>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统实践（四）：利用用户标签数据]]></title>
    <url>%2F2019%2F01%2F06%2F2019-01-04-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%88%A9%E7%94%A8%E7%94%A8%E6%88%B7%E6%A0%87%E7%AD%BE%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[推荐系统实践（四）：利用用户标签数据根据给物品打标签的人的不同，标签应用一般分为两种：一种是让作者或者专家给物品打标签；另一种是让普通用户给物品打标签，也就是UGC（User Generated Content，用户生成的内容）的标签应用。UGC的标签系统是一种表示用户兴趣和物品语义的重要方式。当一个用户对一个物品打上一个标签，这个标签一方面描述了用户的兴趣，另一方面则表示了物品的语义，从而将用户和物品联系了起来。 1 标签系统中的推荐问题1.1 用户为什么进行标注Morgan Ames研究图片分享网站中用户标注的动机问题，并从两个维度进行探讨。 社会维度，有些用户标注是给内容上传者使用的（便于上传者组织自己的信息），而有些用户标注是给广大用户使用的（便于帮助其他用户找到信息）。 功能维度，有些标注用于更好地组织内容，方便用户将来的查找，而另一些标注用于传达某种信息，比如照片的拍摄时间和地点等。 1.2 用户如何打标签标签流行度遵循长尾分布，如下图所示： 横坐标是流行度 $k$，纵坐标是数据集中流行度为 $k$ 的标签总数 $n(k)$。 1.3 用户打什么样的标签 表明物品是什么 表明物品的种类 表明物品所有者 表达用户的观点 用户相关的标签 比如 my favorite （我最喜欢的）、 my comment （我的评论）等。 用户的任务 比如 to read （即将阅读）、 job search （找工作）等 类型、时间、人物、地点、语言、奖项等 其他 2 基于标签的推荐系统2.1 简单算法 统计每个用户最常用的标签。 对于每个标签，统计被打过这个标签次数最多的物品。 对于一个用户，首先找到他常用的标签，然后找到具有这些标签的最热门物品推荐给这个用户。 物品 $u$ 对 $i$ 的兴趣公式如下： p(u,i) = \sum_{i}n_{u,b}n_{b,i}这里， $B(u)$ 是用户 $u$ 打过的标签集合， $B(i)$ 是物品 $i$ 被打过的标签集合， $n_{u,b}$ 是用户 $u$ 打过标签 $b$的次数， $n_{b,i}$ 是物品 $i$ 被打过标签 $b$ 的次数。 2.2 算法改进2.2.1 TF-IDF前面这个公式倾向于给热门标签对应的热门物品很大的权重，因此会造成推荐热门的物品给用户，从而降低推荐结果的新颖性。另外，这个公式利用用户的标签向量对用户兴趣建模，其中每个标签都是用户使用过的标签，而标签的权重是用户使用该标签的次数。这种建模方法的缺点是给热门标签过大的权重，从而不能反应用户个性化的兴趣。这里我们可以借鉴 TF-IDF 的思想，对这一公式进行改进： p(u,i) = \sum_{b}\frac{n_{u,b}}{\log(1 + n_b^{(u)})}n_{b,i}这里，$n_b^{(u)}$ 记录了标签 $b$ 被多少个不同的用户使用过。 同理，我们也可以借鉴 TF-IDF 的思想对热门物品进行惩罚，从而得到如下公式： p(u,i) = \sum_{b}\frac{n_{u,b}}{\log(1 + n_b^{(u)})}\frac{n_{b,i}}{\log(1 + n_i^{(u)})}其中，$n_i^{(u)}$ 记录了物品 $i$ 被多少个不同的用户打过标签。 2.2.2 数据稀疏性在前面的算法中，用户兴趣和物品的联系是通过 $B(u)\cap{B(i)}$ 中的标签建立的。但是，对于新用户或者新物品，这个集合 $B(u)\cap{B(i)}$ 中的标签数量会很少。为了提高推荐的准确率，我们可能要对标签集合做扩展，比如若用户曾经用过“推荐系统”这个标签，我们可以将这个标签的相似标签也加入到用户标签集合中，比如“个性化”、“协同过滤”等标签。 进行标签扩展有很多方法，其中常用的有话题模型（topic model），不过这里遵循简单的原则介绍一种基于邻域的方法。标签扩展的本质是对每个标签找到和它相似的标签，也就是计算标签之间的相似度。最简单的相似度可以是同义词。如果有一个同义词词典，就可以根据这个词典进行标签扩展。如果没有这个词典，我们可以从数据中统计出标签的相似度。 如果认为同一个物品上的不同标签具有某种相似度，那么当两个标签同时出现在很多物品的标签集合中时，我们就可以认为这两个标签具有较大的相似度。对于标签 $b$，令 $N(b)$为有标签 $b$ 的物品的集合，$n_{b,i}$为给物品 $i$ 打上标签 $b$ 的用户数，我们可以通过如下余弦相似度公式计算标签 $b$ 和标签 $b’$ 的相似度： sim(b,b') = \frac{\sum_{i\in{N(b)\cap{N(b')}}}n_{b,i}n_{b',i}}{\sqrt{\sum_{i\in{N(b)}}n_{b,i}^2}\sqrt{\sum_{i\in{N(b')}}n_{b',i}^2}}2.2.3 标签清理 去除不能反应用户的兴趣的标签，例如“无聊”“不好看”等标签 将标签作为推荐解释，有如下方法： （1）去除词频很高的停止词；（2）去除因词根不同造成的同义词，比如 recommender system 和 recommendation system ；（3）去除因分隔符造成的同义词，比如 collaborative_filtering 和 collaborative-filtering 。 （4）控制标签质量，采用用户反馈的方法，让用户告诉系统某个标签是否合适。（ MovieLens 在实验系统中就采用了这种方法。关于这方面的研究可以参考 GroupLens的 Shilad Wieland Sen 同学的博士论文） 3 给用户推荐标签3.1 为什么给用户推荐标签 方便用户输入标签 提高标签质量 3.2 如何给用户推荐标签 给用户 $u$ 推荐整个系统里最热门的标签 给用户 $u$ 推荐物品 $i$ 上最热门的标签 前面两种的融合，该方法通过一个系数将上面的推荐结果线性加权，然后生成最终的推荐结果 基于统计用户常用标签和物品常用标签的算法有一个缺点，就是对新用户或者不热门的物品很难有推荐结果。有两种解决方案： （1）从物品的内容数据中抽取关键词作为标签 （2）针对有结果，但结果不太多的情况，做一些关键词扩展。比如《 MongoDB 权威指南》一书只有一个用户曾经给它打过一个标签 nosql ，那可以加入“数据库”“编程”等必然相关的标签。 文章源自项亮的《推荐系统实践》读书笔记，感兴趣的读者可以参见原书。]]></content>
      <tags>
        <tag>推荐系统</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统实践（三）：冷启动问题]]></title>
    <url>%2F2019%2F01%2F06%2F2019-01-02-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%86%B7%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[推荐系统实践（三）：冷启动问题1 冷启动问题简介实现个性化推荐： ​ 用户冷启动：新用户 ​ 物品冷启动：新物品 ​ 系统冷启动：新网站（没有用户，没有用户行为，只有物品信息） 解决方案： ​ ①提供非个性化推荐，如热门榜单物品等。 ​ ②利用注册信息 ​ ③利用物品内容信息 ​ ④在系统冷启动时，可以引入专家的知识，通过一定的高效方式迅速建立起物品的相关度表 2 利用用户注册信息用户注册信息分为以下3种： 1. **人口统计学信息**：包括用户的年龄、性别、职业、民族、学历和居住地 2. **用户兴趣的描述**：有一些网站会让用户用文字描述他们的兴趣 3. **从其他网站导入的用户站外行为数据**：比如用户通过豆瓣、新浪微博的账号登录，就可以 在得到用户同意的情况下获取用户在豆瓣或者新浪微博的一些行为数据和社交网络数据 基于人口统计学特征的推荐系统其典型代表是Bruce Krulwich开发的Lifestyle Finder。首先，Bruce Krulwich将美国人群根据人口统计学属性分成62类，然后对于每个新用户根据其填写的个人资料判断他属于什么分类，最后给他推荐这类用户最喜欢的15个链接，其中5个链接是推荐他购买的商品，5个链接是推荐他旅游的地点，剩下的5个链接是推荐他去逛的商店。 基于注册信息的个性化推荐基本流程：​ (1) 获取用户的注册信息；​ (2) 根据用户的注册信息对用户分类；​ (3) 给用户推荐他所属分类中用户喜欢的物品。 我们可以用图示的这3张相关表查询出的电视剧列表按照一定权重相加，得到给用户的最终推荐列表。 基于用户注册信息的推荐算法其核心问题是计算每种特征的用户喜欢的物品。即对于每种特征 $f$，计算具有这种特征的用户对各个物品的喜好程度 $p(f, i)$，公式如下： p(f,i) = |N(i)\cap{U(f)}|其中 $N(i)$ 是喜欢物品 $i$ 的用户集合， $U(f)$ 是具有特征 $f$ 的用户集合。 公式缺点：热门物品会在各种特征的用户中都具有比较高的权重，即$|N(i)|$比较高的物品会在每一类用户都有比较高的 $p(f,i)$，而给用户推荐热门物品并不是推荐系统的主要任务，推荐系统应该帮助用户发现他们不容易发现的物品，改进公式如下： p(f,i) =\frac{|N(i)\cap{U(f)}|}{|N(i) + \alpha|}分母中使用参数 $\alpha$ 的目的是解决数据稀疏问题。比如有一个物品只被 1 个用户喜欢过，而这个用户刚好就有特征 $f$ ，那么就有 $p(f,i) = 1$。但是，这种情况并没有统计意义，因此我们为分母加上一个比较大的数，可以避免这样的物品产生比较大的权重。 包含人口统计学信息的数据集： BookCrossing 数据集 和 Lastfm 数据集。 3 利用用户对物品的反馈（启动物品）解决用户冷启动问题的另一个方法是在新用户第一次访问推荐系统时，不立即给用户展示推荐结果，而是给用户提供一些物品，让用户反馈他们对这些物品的兴趣，然后根据用户反馈给提供个性化推荐。 关键问题是如何选择物品让用户反馈？ ①比较热门的 ②具有代表性和区分性的 ③多样性 Nadav Golbandi 在论文中提出可以用一个决策树解决这个问题，首先，给定一群用户， Nadav Golbandi 用这群用户对物品评分的方差度量这群用户兴趣的一致程度。如果方差很大，说明这一群用户的兴趣不太一致，反之则说明这群用户的兴趣比较一致。 令 $\sigma_u\in{U’}$ 为用户集合 $U’$ 中所有评分的方差， Nadav Golbandi 的基本思想是通过如下方式度量一个物品的区分度 $D(i)$: D(i) = \sigma_{u\in{N^+(i)}} + \sigma_{u\in{N^-(i)}} + \sigma_{u\in\overline{N}(i)}其中，$N^+(i)$ 是喜欢物品 $i$ 的用户集合，$N^-(i)$ 是不喜欢物品 $i$ 的用户集合，$\overline{N}(i)$ 是没有对物品 $i$ 评分的用户合。$\sigma_{u\in{N^+(i)}}$ 是喜欢物品 $i$ 的用户对其他物品评分的方差，$\sigma_{u\in{N^-(i)}}$ 是不喜欢物品 $i$ 的用户对其他物品评分的方差， $\sigma_{u\in\overline{N}(i)}$ 是没有对物品 $i$ 评分的用户对其他物品评分的方差。对于物品 $i$ ， Nadav Golbandi 将用户分成 3 类——喜欢物品 $i$ 的用户、不喜欢物品 $i$ 的用户和不知道物品 $i$ 的用户（即没有给 $i$ 评分的用户）。如果这 3 类用户集合内的用户对其他的物品兴趣很不一致，说明物品 $i$ 具有较高的区分度。 算法流程： （1）首先会从所有用户中找到具有最高区分度的物品 $i$ ，然后将用户分成 3类 （2）然后在每类用户中再找到最具区分度的物品，然后将每一类用户又各自分为 3 类，也就是将总用户分成 9 类，然后这样继续下去，最终可以通过对一系列物品的看法将用户进行分类。 （3）冷启动时，从根节点开始询问用户对该节点物品的看法，然后根据用户的选择将用户放到不同的分枝 4 利用物品的内容信息一般来说，物品的内容可以通过向量空间模型表示，该模型会将物品表示成一个关键词向量。如果物品的内容是一些诸如导演、演员等实体的话，可以直接将这些实体作为关键词。但如果内容是文本的形式，则需要引入一些理解自然语言的技术抽取关键词。对于中文，首先要对文本进行分词，将字流变成词流，然后从词流中检测出命名实体（如人名、地名、组织名等），这些实体和一些其他重要的词将组成关键词集合，最后对关键词进行排名，计算每个关键词的权重，从而生成关键词向量。 对物品 $d$ ，它的内容表示成一个关键词向量如下： d_i = \{(e_1,w_1),(e_2,w_2),...\}其中，$e_i$ 就是关键词， $w_i$ 是关键词对应的权重。如果物品是文本，我们可以用信息检索领域著名的 TF-IDF 公式计算词的权重： w_i = \frac{TF(e_i)}{\log{DF(e_i)}}如果物品是电影，可以根据演员在剧中的重要程度赋予他们权重。 在给定物品内容的关键词向量后，物品的内容相似度可以通过向量之间的余弦相似度计算： w_{ij} = \frac{d_i\cdot{d_j}}{\sqrt{||d_i||||d_j||}}内容过滤算法特点： ​ 内容过滤算法忽视了用户行为，从而也忽视了物品的流行度以及用户行为中所包含的规律，因此它的精度比较低，但结果的新颖度比较高。如果用户的行为强烈受某一内容属性的影响，那么内容过滤的算法还是可以在精度上超过协同过滤算法的。不过这种强的内容特征不是所有物品都具有的，而且需要丰富的领域知识才能获得，所以很多时候内容过滤算法的精度比协同过滤算法差。 ​ 内容过滤算法与协同过滤算法两种算法融合，一定能够获得比单独使用这两种算法更好的效果。 另外，ECML/PKDD 在 2011 年举办过一次利用物品内容信息解决冷启动问题的比赛。对内容推荐的详细了解可以关注该比赛的相关论文。 话题模型算法LDA：（详细了解参见： DM Blei 的论文“ Latent Dirichlet Allocation ”） ​ 在使用 LDA 计算物品的内容相似度时，我们可以先计算出物品在话题上的分布，然后利用两个物品的话题分布计算物品的相似度。比如，如果两个物品的话题分布相似，则认为两个物品具有较高的相似度，反之则认为两个物品的相似度较低。计算分布的相似度可以利用 KL 散度： D_{KL}(p||q) = \sum_{i}p(i)ln{\frac{p(i)}{q(i)}}其中 $p$ 和 $q$ 是两个分布， $KL$ 散度越大说明分布的相似度越低。 5 发挥专家的作用通过专家对物品或案例进行特征标记，从而进行相似度计算。 如Pandora个性化电台实现的推荐是通过雇佣一批懂计算机的音乐人进行了一项称为音乐基因的项目，他们听了几万名歌手的歌，并对这些歌的各个维度进行标注。最终，他们使用了 400 多个特征用来标记每首歌。 文章源自项亮的《推荐系统实践》读书笔记，感兴趣的读者可以参见原书。]]></content>
      <tags>
        <tag>推荐系统</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-28-推荐系统实践（二）：利用用户行为数据]]></title>
    <url>%2F2019%2F01%2F06%2F2018-12-28-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%88%A9%E7%94%A8%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[推荐系统实践（二）：利用用户行为数据1 用户行为数据简介显性反馈行为：评分、喜欢/不喜欢等 隐性反馈行为：页面浏览、点击等 用户行为的统一表示，将一个用户行为表示为6部分，即产生行为的用户和行为的对象、行为的种类、产生行为的上下文、行为的内容和权重，如下： user id 产生行为的用户的唯一标识item id 产生行为的对象的唯一标识behavior type 行为的种类（比如是购买还是浏览）context 产生行为的上下文，包括时间和地点等behavior weight 行为的权重（如果是观看视频的行为，那么这个权重可以是观看时长；如果是打分行为，​ 这个权重可以是分数）behavior content 行为的内容（如果是评论行为，那么就是评论的文本；如果是打标签的行为，就是标签） 2 用户行为分析2.1 用户活跃度和物品流行度的分布很多关于互联网数据的研究发现，互联网上的很多数据分布都满足一种称为Power Law的分布，这个分布在互联网领域也称长尾分布。公式如下： f(x) = \alpha{x^k}用户行为数据也蕴含着这种规律，令f _u ( k ) 为对k个物品产生过行为的用户数，令f _i( k ) 为被k个用户产生过行为的物品数。那么，f _u ( k ) 和f _i ( k ) 都满足长尾分布，即： f_i(k) =\alpha_i{k^{\beta_i}} f_u(k) =\alpha_u{k^{\beta_u}} 2.2 用户活跃度和物品流行度的关系一般认为，新用户倾向于浏览热门的物品，因为他们对网站还不熟悉，只能点击首页的热门物品，而老用户会逐渐开始浏览冷门的物品。 仅仅基于用户行为数据设计的推荐算法一般称为协同过滤算法。学术界对协同过滤算法进行了深入研究，提出了很多方法，比如基于邻域的方法（ neighborhood-based ）、隐语义模型（ latent factor model ）、基于图的随机游走算法（ random walk on graph ）等。在这些方法中，最著名的、在业界得到最广泛应用的算法是基于邻域的方法，而基于邻域的方法主要包含下面两种算法: ① 基于用户的协同过滤算法： 这种算法给用户推荐和他兴趣相似的其他用户喜欢的物品。 ② 基于物品的协同过滤算法： 这种算法给用户推荐和他之前喜欢的物品相似的物品。 2.3 基于邻域的算法2.3.1 基于用户的协同过滤算法 基础算法 (1) 找到和目标用户兴趣相似的用户集合。(2) 找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户。 步骤 (1) 的关键就是计算两个用户的兴趣相似度。协同过滤算法主要利用行为的相似度计算兴趣的相似度，给定用户 u 和用户 v ，令 N(u) 表示用户 u 曾经有过正反馈的物品集合，令 N(v)为用户 v 曾经有过正反馈的物品集合。那么，我们可以通过如下的 Jaccard 公式简单地计算 u 和 v 的兴趣相似度： w_{uv} = \frac{|N(u)\cap{N(v)}|}{|N(u)\cup{N(v)}|}​ 或者通过余弦相似度计算： w_{uv} = \frac{|N(u)\cap{N(v)}|}{\sqrt{|N(u)||{N(v)|}}}对两两用户都利用余弦相似度计算相似度。这种方法的时间复杂度是O(|U|*|U|)，这在用户数很大时非常耗时。事实上，很多用户相互之间并没有对同样的物品产生过行为，即很多时候 |N(u)\cap{N(v)}| = 0 。上面的算法将很多时间浪费在了计算这种用户之间的相似度上。如果换一个思路，我们可以首先计算出|N(u)\cap{N(v)}| ≠ 0的用户对(u,v)，然后再对这种情况除以分母\sqrt{|N(u)||{N(v)|}}。 为此，可以首先建立物品到用户的倒排表，对于每个物品都保存对该物品产生过行为的用户列表。令稀疏矩阵C[u][v] = |N(u)\cap{N(v)}|。那么，假设用户u和用户v同时属于倒排表中K个物品对应的用户列表，就有C[u][v]=K。从而，可以扫描倒排表中每个物品对应的用户列表，将用户列表中的两两用户对应的C[u][v]加1，最终就可以得到所有用户之间不为0的C[u][v] 。 UserCF算法：给用户推荐和他兴趣最相似的 K 个用户喜欢的物品，如下公式度量用户u对物品i的感兴趣程度： p(u,i) = \sum_{v\in{S(u,K)}\cap{N(i)}}{w_{uv}}{r_{vi}}其中， S(u, K) 包含和用户 u 兴趣最接近的 K 个用户， N(i) 是对物品 i 有过行为的用户集合，w_{uv}是用户 u 和用户 v 的兴趣相似度，r_{vi}代表用户 v 对物品 i 的兴趣，因为使用的是单一行为的隐反馈数据，所以所有的 r_{vi} = 1 。 可通过改变K值得到不同的性能，进而选择合适的K值。 Random 算法：每次都随机挑选 10 个用户没有产生过行为的物品推荐给当前用户。 MostPopular算法：按照物品的流行度给用户推荐他没有产生过行为的物品中最热门的 10 个物品。 用户相似度计算的改进 John S. Breese 在论文中提出根据用户行为计算用户兴趣的相似度，公式如下： w_{uv} = \frac{\sum_{i\in{N(u)\cap{N(v)}}}{\frac{1}{\log1 + |N(i)|}}}{\sqrt{|N(u)||N(v)|}}​ 公式通过\frac{1}{\log1 + |N(i)|}惩罚了用户 u 和用户 v 共同兴趣列表中热门物品对他们相似度的影响。 实际在线系统中使用UserCF的例子 相比基于物品的协同过滤算法（ ItemCF ）， UserCF 在目前的实际应用中使用并不多。典型的代表是Digg，Digg 的推荐系统设计思路如下，用户在 Digg 中主要通过“顶”和“踩”两种行为表达自己对文章的看法。当用户顶了一篇文章， Digg 就认为该用户对这篇文章有兴趣，而且愿意把这篇文章推荐给其他用户。然后， Digg找到所有在该用户顶文章之前也顶了这一篇文章的其他用户，然后给他推荐那些人最近顶的其他文章。从这里的简单描述可以看到， Digg 使用的是 UserCF 算法的简化版本。 2.3.2 基于物品的协同过滤算法UserCF算法的缺陷： ​ ①随着网站的用户数目越来越大，计算用户兴趣相似度矩阵将越来越困难，其运算时间复杂度和空间复杂度的增长和用户数的增长近似于平方关系； ​ ②UserCF很难对推荐结果作出解释 基于物品的协同过滤（ item-based collaborative filtering ）算法是目前业界应用最多的算法。 基础算法 ItemCF 算法并不利用物品的内容属性计算物品之间的相似度，它主要通过分析用户的行为记录计算物品之间的相似度。该算法认为，物品 A 和物品 B 具有很大的相似度是因为喜欢物品 A 的用户大都也喜欢物品B 。 基于物品的协同过滤算法主要分为两步：​ (1) 计算物品之间的相似度。​ (2) 根据物品的相似度和用户的历史行为给用户生成推荐列表。 物品相似度计算公式（原理：购买了该商品的用户也经常购买的其他商品）： w_{ij} = \frac{|N(i)\cap{N(j)}|}{|N(i)|}分母 |N(i)| 是喜欢物品 i 的用户数，而分子 |N(i)\cap{N(j)}|是同时喜欢物品 i 和物品 j 的用户数。因此，上述公式可以理解为喜欢物品 i 的用户中有多少比例的用户也喜欢物品 j 。 上述公式存在的问题：物品 j 很热门，很多人都喜欢，那么 w_{ij} 就会很大，接近 1 。因此，该公式会造成任何物品都会和热门的物品有很大的相似度，不利于挖掘处于长尾的物品。 改进后的公式： w_{ij} = \frac{|N(i)\cap{N(j)}|}{\sqrt{|N(i)||N(j)|}}这个公式惩罚了物品 j 的权重，因此减轻了热门物品会和很多物品相似的可能性。 在得到物品之间的相似度后，ItemCF通过如下公式计算用户 u 对一个物品 j 的兴趣： p_{uj} = \sum_{i\in{N(u)}\cap{S(j,K)}}{w_{ji}}{r_{ui}}其中N(u)是用户喜欢的物品的集合，S(j,K)是和物品 j 最相似的K个物品的集合，w_{ji} 是物品 j 和 i的相似度，r_{ui} 是用户 u 对物品 i 的兴趣。（对于隐反馈数据集，如果用户 u 对物品 i 有过行为，即可令r_{ui} = 1 。） 例子说明： ItemCF 给用户推荐《算法导论》，是因为这本书和《 C++ Primer 中文版》相似，相似度为 0.4 ，而且这本书也和《编程之美》相似，相似度是 0.5 。考虑到用户对《 C++ Primer 中文版》的兴趣度是 1.3 ，对《编程之美》的兴趣度是 0.9 ，那么用户对《算法导论》的兴趣度就是 1.3 × 0.4 + 0.9 × 0.5 = 0.97。推荐列表最终是兴趣度排名前K个。 注意：通过选择不同的K值进行性能测试，最终得到最合适的K值。 用户活跃度对物品相似度的影响 两个物品产生相似度是因为它们共同出现在很多用户的兴趣列表中，即每个用户的兴趣列表都对物品的相似度产生贡献。而每个用户的贡献是不同的，John S. Breese 在论文中提出了一个称为 IUF （ Inverse User Frequence ），即用户活跃度对数的倒数的参数，他认为活跃用户对物品相似度的贡献应该小于不活跃的用户，他提出应该增加 IUF参数来修正物品相似度的计算公式： w_{ij} = \frac{\sum_{u\in{N(i)\cap{N(j)}}}{\frac{1}{\log1 + |N(u)|}}}{\sqrt{|N(i)||N(j)|}}对于过于活跃的用户，可考虑不将其纳入到相似度计算的数据集中。 物品相似度的归一化 Karypis 在研究中发现如果将 ItemCF 的相似度矩阵按最大值归一化，可以提高推荐的准确率。公式如下： w_{ij}' = \frac{w_{ij}}{\max_j{w_{ij}}}归一化的好处不仅仅在于增加推荐的准确度，它还可以提高推荐的覆盖率和多样性。 2.3.3 UserCF和ItemCF的对比 UserCF 的推荐结果着重于反映和用户兴趣相似的小群体的热点，更社会化，反映了用户所在的小型兴趣群体中物品的热门程度，用于新闻推荐等； ItemCF的推荐结果着重于维系用户的历史兴趣，更加个性化，反映了用户自己的兴趣传承，用于电商推荐等。 哈利波特问题 亚马逊网的研究人员在设计 ItemCF 算法之初发现 ItemCF 算法计算出的图书相关表存在一个问题，就是很多书都和《哈利波特》相关。也就是说，购买任何一本书的人似乎都会购买《哈利波特》。 回顾一下 ItemCF 计算物品相似度的经典公式： w_{ij} = \frac{|N(i)\cap{N(j)}|}{\sqrt{|N(i)||N(j)|}}如果 j 非常热门，那么上面公式的分子 |N(i)\cap{N(j)}| 就会越来越接近 |N(i)|。尽管上面的公式分母已经考虑到了 j 的流行度，但在实际应用中，热门的 j 仍然会获得比较大的相似度，因此可加大对热门物品的惩罚，再改进后的公式如下： w_{ij} = \frac{|N(i)\cap{N(j)}|}{|N(i)|^{1-\alpha}|N(j)|^\alpha}其中 \alpha\in[0.5 ,1]​ 。通过提高 \alpha​ ，就可以惩罚热门的 j​ 。 注意：α＝ 0.5 就是标准的 ItemCF 算法， α 只有在取值为 0.5 时才会导致最高的准确率和召回率，而无论 α＜ 0.5 或者 α ＞ 0.5 都不会带来这两个指标的提高。但是，如果看覆盖率和平均流行度就可以发现， α 越大，覆盖率就越高，并且结果的平均热门程度会降低。因此，通过这种方法可以在适当牺牲准确率和召回率的情况下显著提升结果的覆盖率和新颖性（降低流行度即提高了新颖性）。 然而两个领域的最热门物品往往会有较高的相似度，协同过滤无法解决。 2.4 隐语义模型隐语义模型指通过隐含特征联系用户兴趣和物品。 隐含语义分析技术：采取基于用户行为统计的自动聚类。该技术相关且耳熟能详的名词有 pLSA 、 LDA 、隐含类别模型（ latent class model ）、隐含主题模型（ latent topic model ）、矩阵分解（ matrix factorization ）等。 可以对物品的兴趣进行分类。对于某个用户，首先得到他的兴趣分类，然后从分类中挑选他可能喜欢的物品。 （1）给物品分类 （2）确定用户对哪些类的物品感兴趣，以及感兴趣的程度 （3） 对于一个给定的类，确定这些物品在一个类中的权重，选择K个属于这个类的物品推荐给用户 LFM隐语义模型基础算法 LFM 计算用户 u 对物品 i 的兴趣的公式如下： Preference(u,i) = r_{ui} = p_u^Tq_i = \sum_{f = 1}^F{p_{u,k}q_{i,k}}这个公式中 p_{u,k} 和 q_{i,k} 是模型的参数，其中p_{u,k}度量了用户 u 的兴趣和第 k 个隐类的关系，而q_{i,k}度量了第 k 个隐类和物品 i 之间的关系。因此，关键在于这两个参数的计算。 推荐系统的用户行为分为显性反馈和隐性反馈。 LFM 在显性反馈数据（也就是评分数据）上解决评分预测问题并达到了很好的精度，下面主要讨论隐性反馈数据集，这种数据集的特点是只有正样本（用户喜欢什么物品），而没有负样本（用户对什么物品不感兴趣）。那在应用LFM时如何生成负样本呢？Rong Pan给出了以下几种方案并进行了对比： ​ ①对于一个用户，用他所有没有过行为的物品作为负样本。缺点是负样本太多，正负样本数目相差悬殊，计算复杂度高，精度低； ​ ②对于一个用户，从他没有过行为的物品中均匀采样出一些物品作为负样本。 ​ ③对于一个用户，从他没有过行为的物品中采样出一些物品作为负样本，但采样时，保证每个用户的正负样本数目相当。 ​ ④对于一个用户，从他没有过行为的物品中采样出一些物品作为负样本，但采样时，偏重采样不热门的物品。 ​ 性能由高到底排序：③ &gt; ② ＞④ &gt; ① 负样本采样应遵循的原则： ​ ① 对每个用户，要保证正负样本的平衡（数目相似）； ​ ② 对每个用户采样负样本时，要选取那些很热门，而用户却没有行为的物品 通过采样得到一个用户—物品集 K = \{(u,i)\} ，其中如果(u,i)是正样本，则有 r_{ui} = 1，否则有r_{ui} = 0。然后需要优化如下的损失函数来找到最合适的参数 p 和 q ： C = \sum_{(u,i)\in{K}}(r_{ui} - \overline{r_{ui}})^2 = \sum_{(u,i)\in{K}}(r_{ui} - \sum_{k = 1}^K{p_{u,k}q_{i,k}})^2 + \lambda{||p_u||}^2 + \lambda{||q_i||}^2其中，\lambda{||p_u||}^2 + \lambda{||q_i||}^2是用来防止过拟合的正则化项，λ可以通过实验获得。要最小化上面的损失函数，可以利用一种称为随机梯度下降法的算法。该算法是最优化理论里最基础的优化算法，它首先通过求参数的偏导数找到最速下降方向，然后通过迭代法不断地优化参数。 上面定义的损失函数里有两组参数p_{u,k}和q_{i,k} ，随机梯度下降法需要首先对它们分别求偏导数，可以得到： \frac{\partial C}{\partial p_{uk}} = -2q_{ik} + 2\lambda{p_{uk}} \frac{\partial C}{\partial q_{ik}} = -2p_{uk} + 2\lambda{q_{ik}}然后，根据随机梯度下降法，需要将参数沿着最速下降方向向前推进，因此可以得到如下递推公式： p_{uk} = p_{uk} + \alpha(q_{ik} - \lambda{p_{uk}}) q_{ik} = q_{ik} + \alpha(p_{uk} - \lambda{q_{ik}})其中， α 是学习速率（learning rate），它的选取需要通过反复实验获得。 基于LFM的实际系统的例子 LFM 模型在实际使用中有一个困难，那就是它很难实现实时的推荐，且训练参数的过程很耗时。雅虎通过改善LFM模型解决了此困难。首先，他们利用新闻链接的内容属性（关键词、类别等）得到链接 $i$ 的内容特征向量 $y_i$ 。其次，他们会实时地收集用户对链接的行为，并且用这些数据得到链接 $i$ 的隐特征向量 $q_i$ 。然后，他们会利用如下公式预测用户 $u$ 是否会单击链接 $i$ ： r_{ui} = x_u^{T}\cdot{y_i} + p_u^T\cdot{q_i}其中， $y i$ 是根据物品的内容属性直接生成的， $x_{uk}$ 是用户 $u$ 对内容特征 $k$ 的兴趣程度，用户向量 $x_u$ 可以根据历史行为记录获得，而且每天只需要计算一次。而 $p_u$ 、$q_i$ 是根据实时拿到的用户最近几小时的行为训练 LFM 获得的。因此，对于一个新加入的物品 $i$ ，可以通过$x_u^{T}\cdot{y_i} $估计用户 $u$ 对物品 $i$ 的兴趣，然后经过几个小时后，就可以通过 $p_u^T\cdot{q_i}$得到更加准确的预测值。 具体方法详情可参见雅虎报告！ LFM和基于邻域的方法的比较 ①理论基础：LFM有较好的理论基础 ②离线计算的空间复杂度：基于邻域的方法需要维护一张离线的相关表，假设有 M 个用户和 N 个物品，对于UserCF，需要 $O(MM)$ 的空间，对于ItemCF，需要 $O(NN)$ 的空间，而 LFM 在建模过程中，如果是 F 个隐类，那么它需要的存储空间是 $O(F(M+N))$ ，这在M 和 N 很大时可以很好地*节省离线计算的内存。 ③离线计算的时间复杂度：一般情况下， LFM 的时间复杂度要稍微高于 UserCF 和 ItemCF ，这主要是因为该算法需要多次迭代。但总体上，这两种算法在时间复杂度上没有质的差别。 ④ 在线实时推荐：UserCF 和 ItemCF 在线服务算法需要将相关表缓存在内存中，然后可以在线进行实时的预测。以 ItemCF 算法为例，一旦用户喜欢了新的物品，就可以通过查询内存中的相关表将和该物品相似的其他物品推荐给用户。 LFM 在给用户生成推荐列表时，需要计算用户对所有物品的兴趣权重，然后排名，返回权重最大的 N 个物品。那么，在物品数很多时，这一过程的时间复杂度非常高，可达 $O(MNF)$ 。 LFM 不太适合用于物品数非常庞大的系统，如果要用，我们也需要一个比较快的算法给用户先计算一个比较小的候选列表，然后再用LFM 重新排名。 ⑤ 推荐解释：ItemCF 算法支持很好的推荐解释，它可以利用用户的历史行为解释推荐结果。但 LFM 无法提供这样的解释，它计算出的隐类虽然在语义上确实代表了一类兴趣和物品，却很难用自然语言描述并生成解释展现给用户。 2.5 基于图的模型2.5.1 二分图表示​ 用户A、B、C、D，物品a、b、c、d，表示如下： 2.5.2 基于图的推荐算法度量图中顶点的相关性： ​ ①两个顶点之间的路径数； ​ ②两个顶点之间路径的长度； ​ ③两个顶点之间的路径经过的顶点。 相关性高的顶点：两个顶点之间有很多路径相连，连接两个顶点之间的路径长度都比较短，连接两个顶点之间的路径不会经过出度比较大的顶点。 计算图中顶点之间相关性的方法：基于随机游走的PersonalRank算法。 文章源自项亮的《推荐系统实践》读书笔记，感兴趣的读者可以参见原书。]]></content>
      <tags>
        <tag>推荐系统</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统入门学习系列（一）：推荐系统方法概述及基于内容的推荐系统]]></title>
    <url>%2F2018%2F12%2F27%2F2018-12-26-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[推荐系统入门学习系列（一）：推荐系统方法概述及基于内容的推荐系统1 推荐系统中的数据挖掘方法1.1 数据预处理1.1.1 相似度度量方法 欧几里得距离 d(x,y) = \sqrt{\sum_{k=1}^{n}{(x_k - y_k) ^ 2}}​ 闵可夫斯基距离是欧几里得距离的推广： d(x,y) = (\sum_{k=1}^{n}|x_k - y_k|^r)^\frac{1}{r}​ r = 1，城市街区（曼哈顿、出租车、L1范数）距离； ​ r = 2，欧几里得距离。 余弦值 cos(x,y) = \frac{(x \cdot y)}{|x||y|}· 表示向量的点积，|x|表示向量x的长度。 皮尔逊相关系数 Peason(x,y) = \frac{\sum(x,y)}{\sigma_x * \sigma_y} 推荐系统一般会使用余弦相似度或者皮尔逊相关性。Spertus在Orkut社交网络的环境中做了大规模的研究来评估六种不同的相似度度量方法，发现余弦相似度是其中效果最好的方法。Lathia同样做了相关研究，总结出在一般案例中，推荐系统的预测精准性不受相似度度量方法选择的影响，甚至使用随机的相似度度量方法有时会产生比使用众所周知的方法效果更好。 1.1.2 抽样 无取代抽样 取代抽样 分层抽样 推荐系统中常用的方法是从用户中抽取可用的反馈以用户评分的形式来划分训练和测试。根据场景的不同，选择不同的抽样方法。 1.1.3 降维 主成分分析法（PCA） PCA用来发现高维数据集中的模式，可以获得一组有序的成分列表，其根据最小平方误差计算出变化最大的值。列表中第一个成分所代表的变化量要比第二个成分所代表的变化量大，以此类推。我们可以通过忽略这些对变化贡献较小的成分实现降维。 PCA的局限性： ​ ①PCA依赖于以线性合并为基础的经验数据集，尽管一般的非线性PCA方法已经提出。 ​ ②PCA的原始数据集需要是从高斯分布中抽取出来的，否则无法保证主要成分的有效性。 奇异值分解（SVD） SVD是矩阵分解方法的特殊实现，和PCA相关。SVD分解中的关键问题是发现低维特征空间，这些新特征代表概念以及在集合内容中的每一个概念强度都是可计算的。 A_{n×m} = U_{n×r}\lambda_{r×r}V_{r×m}数据A（n个物品，m个特征），矩阵U（n个物品，r个概念），对角矩阵R（概念的长度），矩阵V（m特征，r概念） 矩阵分解（MF） 1.1.4 去噪噪声：数据收集阶段收集到的一些可能影响数据分析和解释结果的伪造数据。分为自然的和恶意的噪声。恶意的噪声影响推荐的输出，可通过要求用户重新填写一些物品的评价来去噪，提高精确度。 通过预处理步骤来提高精确度能够比复杂的算法优化效果好得多。 1.2 分类分类器是从特征空间到标签空间的映射，其中特种空间代表需要分类的元素的属性，标签代表类别。 1.2.1 最近邻KNN基于样本的分类通过存储训练记录并使用它们来预测未知样本的标签分类。KNN是基于样本的分类。给出一个要分类的点，KNN分类器能够从训练记录中发现k个最近的点。 KNN最关键的问题是k值的选择，若k太小，分类可能对噪声点太敏感；若k太大，近邻范围内可能会包含其他类太多的点。 近邻算法是协同过滤（CF）最常用的一种方法，KNN不需要学习和维持一个给定的模型，系统能适应用户评分矩阵的急速变化，但这是以重新计算邻居和相似矩阵为代价的。 1.2.2 决策树使用决策树建立分类器的优点： ​ ①构建代价较小，且在分类未知对象方面速度较快 ​ ②与其他分类器相比，决策树在维持精度的同时，它产生的一系列规则容易被解释 推荐系统中的决策树可以用在基于模型的方法里。一种可能是用内容特征建立决策树模型，对描述用户偏好的所有变量建模。 决策树可以用来模拟系统的一个特殊部分，Cho等提出一个结合关联规则和决策树的在线购物推荐系统，决策树被用来作为一个过滤器来选择哪些用户可以作为推荐的目标。 另一个使用决策树的选择是使用它们作为物品排序的工具。 1.2.3 基于规则的分类基于规则的分类器是通过一组“if…then…”的规则集合划分数据。规则的前提或条件是属性连词的表达式。规则的结论是一个正或者负的分类。 覆盖性：如果对象的属性满足规则的条件，可以说规则R覆盖对象x。规则的覆盖性为满足前提的部分记录。 准确性：既满足前提有满足结论的部分记录。 互斥的规则：规则彼此间是独立的，如每一个记录最多被一个规则覆盖。 详尽规则：属性值的所有可能组合都被覆盖，如一个记录至少被一个规则覆盖。 1.2.4 贝叶斯分类器贝叶斯分类器把每一个属性和类标签当作随机变量。假设属性的概率独立，则有： P(A_1,A_2,...,A_N|C_k) = P(A_1|C_k)P(A_2|C_k)...P(A_N|C_k)朴素贝叶斯的优点： ​ ①受孤立噪声点和不相关的属性的影响小 ​ ②概率估算期间可以通过忽略实例来处理缺失值 贝叶斯分类器常用于基于模型的推荐系统，被用来为基于内容的推荐系统生成模型。 1.2.5 人工神经网络ANNANN的主要优点是能够做非线性的分类任务（取决于激活函数），并且由于并行属性，它们高效甚至能够在部分网络受损的情况下操作。 缺点是很难对给定的问题提供理想的拓扑结构，并且一旦拓扑结构确定后，它的表现水平就会位于分类错误率的下限。ANN是一种黑盒方法。 ANN能够以类似于贝叶斯网络的方法用于构建基于模型的推荐系统，但是，没有令人信服的研究表明ANN是否能提高性能。 ANN可以用来结合（或是混合）几个推荐模块或者数据源的输入。 1.2.6 支持向量机支持向量机分类（SVM）的目标是发现数据的线性超平面（决策边界），以边界最大化的方式分离数据。 推荐系统中常用SVM预测缺失值。 1.2.7 分类器的集成分类器集成的思想是，从训练数据构造一系列的分类器，并通过聚集预测值来预测类标签。只要我们能假设这些分类器都是独立的，分类器集成就有效。在这种情况下，我们可以确定分类器产生的最糟糕结果与在集成中的最坏分类是一样的。因此，结合具有相似的分类错误的独立分类器将只会提升结果。 1.2.8 评估分类器相关指标：预测兴趣（评分）和测量值的均方差（MAE）或均方根误差（RMSE）、准确率、召回率、F值 1.3 聚类扩展CF分类器的最大问题是计算距离时的操作量，如发现最好的K近邻。一种可能的解决方法是降维，但是即使降低了维度，仍有许多对象要计算距离，这就需要用到聚类。 聚类算法有两个类别： 1. 分层。分层聚类算法在已知聚类上继续聚合物品，生成聚类的嵌套集合，组成一个层级树。 2. 划分。划分聚类算法是将数据划分为非重合的聚类，使每个数据项确切在一个聚类中。 聚类在推荐系统中一般被用来提高性能，不管是用户空间还是物品空间，较早进行聚类步骤都能减少随后要做的计算距离的操作数量。但是，这一般以较低的精确度为代价，因此要慎重选择。事实上，通过降维来提高效率是一般例子中好的选择。 1.3.1 K-meansK-means聚类是一种分块方法。 1）从N个文档随机选取K个文档作为质心 2）对剩余的每个文档测量其到每个质心的距离，并把它归到最近的质心的类 3）重新计算已经得到的各个类的质心 4）迭代2～3步直至新的质心与原质心相等或小于指定阈值，算法结束 缺陷： ​ ①为了选择合适的k值，假定有先验的数据知识 ​ ②最终的聚类对于初始的中心点非常敏感 ​ ③时间开销大，会产生空聚类 1.3.2 改进的K-means算法 基于密度的聚类算法 消息传递聚类算法 分层聚类 以上K-means的替代方法都还没有应用到推荐系统中，k-means算法的简单和效率由于它的替代算法。 1.3.3 关联规则挖掘给定一组事务集合T，关联规则挖掘的目标是发现具有支持度大于等于最小支持度阈值以及置信度大于等于最小置信度阈值的所有规则。 2 基于内容的推荐系统灵感：网站可以根据收集到的用户信息如职业、年龄等切换显示的主题。 基于内容的推荐系统通过分析一系列用户之前已评分物品的文档和描述，从而基于用户已评分对象的特征建立模型或个人信息。 2.1 主要结构 内容分析器：将非结构化的信息结构化 信息学习器：收集有关用户偏好的数据特征，并试图泛化这些数据，从而构建用户特征信息 过滤组件：将用户个人信息与物品在表示空间进行匹配，利用用户个人信息来推荐相关物品 反馈： ①显式反馈：喜欢/不喜欢、评分、文本评论 ②隐式反馈：保存、删除、打印、收藏 2.2 优缺点相对于CF算法的优点： ​ ①用户独立性：仅适用当前用户提供的评分来构建自己的个人信息。 ​ ②透明度：显式列出使得物品出现在推荐列表中的内容特征和描述，可解释推荐系统如何工作。CF是个黑盒子。 ​ ③新物品：基于内容的推荐系统在没有任何用户评分的情况下也可以进行推荐，CF不行。 缺点： ​ ①可分析的内容有限：领域知识是必需的，如电影推荐需要知道电影的演员、导演等。可分析的物品的描述要足够多。 ​ ②过度特化：无法发现一些出人意料的物品。 ​ ③新用户：新用户评分很少，无法给出可靠的推荐。 2.3 物品表示2.3.1 基于关键字向量空间模型大多数基于内容的推荐系统使用相对简单的搜索模型，如关键字匹配法或基于TF-IDF权重的向量空间模型。 向量空间模型：文本文档的空间表示方法，每个文档被表示成一个n维空间的向量，每一维对应给定文档中的一个词。 用 D=\{d_1,d_2,...,d_n\}表示一个文档集合或语料库，用 T=\{t_1,t_2,...,t_n\}表示词典，即语料库中词的集合。 每篇文档d_j表示n维空间中的一个向量，从而 d_j=\{w_{1j},w_{2j},...w_{nj}\}其中w_{kj}是文档d_j中t_k的权重。 常用的加权模式（给单词赋予权重）有基于文本实验观察结果的TF-IDF（词频——逆文档频率）： ​ ①稀有词相关性不小于频繁词相关性（逆文档频率假设） ​ ②一篇文档中多处出现的词的相关性不小于只出现一次词的相关性 ​ ③长文档不一定好于段文档（归一化假设） 即在一篇文档中频繁出现（TF=词频）但很少出现在语料库中其他文档（IDF=逆文档频率）的单词，与该文档主题的相关性可能很大。另外，结果权重向量的归一化防止了长文档有更好的检索机会的问题。 TF-IDF函数很好的解释了上述假设： TF-IDF(t_k,d_j) = TF(t_k,d_j)\cdot\log{\frac{N}{n_k}}N表示语料库中文档的个数，n_k表示含有词单词tk出现至少一次的文档集合的数量。 TF(t_k,d_j) = \frac{f_{k,j}}{max_zf_{z,j}}最大值是出现在文档d_j中所有单词t_z的词频f_{z,j}上计算的。 余弦归一化： w_{k,j} = \frac{TF-IDF(t_k,d_j)}{\sqrt{\sum_{s=1}^{|T|}{TF-IDF(t_s,d_j)^2}}}文档相似度采用余弦相似度度量应用较为广泛： sim(d_i,d_j) = \frac{\sum_{k}{w_{ki}\cdot{w_{kj}}}}{\sqrt{\sum_{k}{w_{ki}^2}}\cdot\sqrt{\sum_{k}{w_{kj}^2}}}2.3.2 基于关键词系统2.3.3 运用本体的语义分析2.3.4 运用百科全书式的知识源进行语义分析2.4 学习用户特征的方法2.4.1 概率方法和朴素贝叶斯 P(c|d) = \frac{P(c)P(d|c)}{P(d)}上述用来估计文档d属于类别c的后验概率P（c|d），估计基于先验概率P（c），即观测到一个文档属于类别c的概率，P（d|c）即在给定类别c的情况下观测到文档d的概率，P（d）是观测到文档d的概率。 为了对文档d分类，选择概率最高的作为类别： c = argmax_{c_j}\frac{P(c_j)P(d|c_j)}{P(d)}P(d)与所有类别c_j相等时，一般将其去掉。当我们不知道P(d|c)和P(c)的值时，我们利用观测到的训练数据对它们进行估计。 有两个被普遍使用的朴素贝叶斯分类模型：多元伯努利事件模型和多项式事件模型。经验表明，多项式朴素贝叶斯公式胜过多元伯努利模型，计算方式如下： P(c_j|d_i) = P(c_j)\prod_{w\in{V_{d_j}}}^{}{P(t_k|c_j}N_{(d_i,t_k)}其中N_(d_j,t_k)表示词或记号t_k在文档d_i出现的次数。这里要注意，仅是文档d_i中包含的词汇表子集V_{d_i}的概率相乘，而不是整个语料库中词汇表V所有的词的概率相乘。 2.4.2 相关反馈和Rocchio算法相关反馈是一个信息检索应用中的技术，它帮助用户逐步完善基于之前搜索结果的查询。 基本原则是允许用户给推荐系统根据用户的信息需求推荐的文本打分。这种形式的反馈随后被用来逐步改善用户特征，或者为训练将用户个人信息作为分类器的学习算法使用。 一些线性的分类器由类别的显式描述（或原始文档）组成。Rocchio算法是一个可用于推导出这种线性的且带有描述风格的分类器。该算法将文档表示成向量，因此有相似内容的文档有相似的向量。 Rocchio计算一个分类c_i的向量\vec{c_i}=（T是词汇表，训练集里不用词的集合），公式如下： w_{ki} = \beta\cdot\sum_{\{d_j\in{POS_i}\}}^{}{\frac{w_{kj}}{|POS_i|}} - \gamma\cdot\sum_{\{d_j\in{NEG_i}\}}^{}{\frac{w_{kj}}{|NEG_i|}}其中w_{kj}​是文档d_j​中词t_k​的TF-IDF权重，POS_i​和NEG_i​是指定类别c_j​中的正例和负例样本集合。\beta​和\gamma​是控制参数，可以用来设置所有正例与负例样本的相关程度。计算文档向量\vec{d_j}​与每个类别的原型向量\vec{c_i}​的相似度，和c_i​相似度最高的类别为\overline{c}​，则将\overline{c}​作为文档\vec{d_j}​的类别。 基于Rocchio的分类算法没有任何理论基础，也不保证有效或收敛。 2.4.3 其他方法决策树、决策规则分类器、最近邻算法等。 2.5 趋势和未来研究在科研领域受到许多关注的一种用户产生内容（UGC）的方法是大众分类法，这是一种由用户产生的分类学，用户大量地选择被称为标签的关键字来协助标注和分类感兴趣的资源。 2.5.1 推荐系统的社会化标签①标签标注用户：如电影推荐系统中，对于活跃用户，推荐算法基于电影之间的相似度计算 ②标签标注物品：标签可以携带相应的分数以代表用户在标签上的兴趣程度。 知识源WORDNET或维基等可以用于识别标签。 2.5.2 超越特化：惊喜度若列表中的物品与用户以前用过的物品特别相似，则需要过滤掉。 新颖性：系统建议给用户一个他以及能独立发现的位置物品； 惊喜度：推荐系统帮助用户找到使用其他方法无法发现的一个令人惊讶的有趣物品。 “可操作地推导出意外惊喜”的策略： ​ ①碰运气或者撞大运，通过随机信息节点产生来实现； ​ ②Pasteur法则（机会垂青有准备的人），通过用户个人信息实现； ​ ③不寻常情况和例外情况，通过弱相似度量来部分实现； ​ ④类比推理，实现目前未知。 基本假设：用户知道物品的概率越低，特定物品导致意外惊喜的概率越高。 想法：推荐时，可以大量推荐用户更可能感兴趣的物品，中间掺杂可能制造惊喜的物品。 文章源自项亮的《推荐系统实践》读书笔记，感兴趣的读者可以参见原书。]]></content>
      <tags>
        <tag>推荐系统</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统实践（一）：推荐系统评测]]></title>
    <url>%2F2018%2F12%2F27%2F2018-12-27-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%AF%84%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[推荐系统实践（一）：推荐系统评测1 推荐系统实验方法1.1 离线实验 处理步骤： (1) 通过日志系统获得用户行为数据，并按照一定格式生成一个标准的数据集；(2) 将数据集按照一定的规则分成训练集和测试集；(3) 在训练集上训练用户兴趣模型，在测试集上进行预测；(4) 通过事先定义的离线指标评测算法在测试集上的预测结果。 优点： ①不需要有对实际系统的控制权②不需要用户参与实验③速度快，可以测试大量算法 缺点： ①无法计算商业上关心的指标 ②离线实验的指标和商业指标存在差距，即高预测准确率不等于高用户满意度 1.2 用户调查用户调查需要有一些真实用户，让他们在需要测试的推荐系统上完成一些任务。在他们完成任务时，我们需要观察和记录他们的行为，并让他们回答一些问题。最后，我们需要通过分析他们的行为和答案了解测试系统的性能。 优点： 可以获得很多体现用户主观感受的指标，相对在线实验风险很低，出现错误后很容易弥补。 缺点： ①招募测试用户代价较大，很难组织大规模的测试用户，因此会使测试结果的统计意义不足。 ②在很多时候设计双盲实验非常困难，而且用户在测试环境下的行为和真实环境下的行为可能有所不同，因而在测试环境下收集的测试指标可能在真实环境下无法重现。 注意事项： ①在做用户调查时，一方面要控制成本，另一方面又要保证结果的统计意义 ②测试用户的选择：需要尽量保证测试用户的分布和真实用户的分布相同，比如男女各半，以及年龄、活跃度的分布都和真实用户分布尽量相同。此外，用户调查要尽量保证是双盲实验，不要让实验人员和用户事先知道测试的目标，以免用户的回答和实验人员的测试受主观成分的影响。 1.3 在线实验在完成离线实验和必要的用户调查后，可以将推荐系统上线做AB测试。AB测试是一种很常用的在线评测算法的实验方法。它通过一定的规则将用户随机分成几组，并对不同组的用户采用不同的算法，然后通过统计不同组用户的各种不同的评测指标比较不同算法，比如可以统计不同组用户的点击率，通过点击率比较不同算法的性能。 （详细学习AB测试参见：http://www.abtests.com/） AB测试的优点：可以公平获得不同算法实际在线时的性能指标，包括商业上关注的指标。 AB测试的缺点： ​ ①实验周期长，必须长期实验才能得到可靠的结果。因此一般不会用AB测试测试所有的算法，而只是用它测试那些在离线实验和用户调查中表现很好的算法。 ​ ②一个大型网站的AB测试系统的设计也是一项复杂的工程，各个层次之间的AB测试可能互相干扰。如，当我们进行一个后台推荐算法的AB测试，同时网页团队在做推荐页面的界面AB测试，最终的结果就是你不知道测试结果是自己算法的改变，还是推荐界面的改变造成的。因此，切分流量是AB测试中的关键，不同的层以及控制这些层的团队需要从一个统一的地方获得自己AB测试的流量，而不同层之间的流量应该是正交的。 1.4 总结一个新的推荐算法最终上线，需要完成上面所说的3个实验： ①首先，需要通过离线实验证明它在很多离线指标上优于现有的算法 ②然后，需要通过用户调查确定它的用户满意度不低于现有的算法 ③最后，通过在线的AB测试确定它在我们关心的指标上优于现有的算法 2 评测指标2.1 用户满意度用户满意度没有办法离线计算，只能通过用户调查或者在线实验获得。 用户调查获得用户满意度主要是通过调查问卷的形式； 在线实验中，用户满意度主要通过一些对用户行为的统计得到，如购买、反馈信息、点击率、用户停留时间和转化率等。 2.2 预测准确度主要通过离线实验评测。 评分预测 很多提供推荐服务的网站都有一个让用户给物品打分的功能。那么，如果知道了用户对物品的历史评分，就可以从中习得用户的兴趣模型，并预测该用户在将来看到一个他没有评过分的物品时，会给这个物品评多少分。 主要指标：均方根误差（RMSE）和平均绝对误差（MAE）。 指标优缺点： Netflix 认为 RMSE 加大了对预测不准的用户物品评分的惩罚（平方项的惩罚），因而对系统的评测更加苛刻。研究表明，如果评分系统是基于整数建立的（即用户给的评分都是整数），那么对预测结果取整会降低 MAE 的误差。 Top-N预测 网站在提供推荐服务时，一般是给用户一个个性化的推荐列表。 主要指标：准确率（ precision ）和召回率（ recall ），为了全面评测 TopN 推荐的准确率和召回率，一般会选取不同的推荐列表长度 N ，计算出一组准确率 / 召回率，然后画出准确率 / 召回率曲线。 2.3 覆盖率覆盖率（ coverage ）描述一个推荐系统对物品长尾的发掘能力。覆盖率有不同的定义方法，最简单的定义为推荐系统能够推荐出来的物品占总物品集合的比例。 主要指标：覆盖率、信息熵、基尼系数。 马太效应：强者更强，弱者更弱。评测推荐系统是否具有马太效应的简单办法就是使用基尼系数。如果 G1 是从初始用户行为中计算出的物品流行度的基尼系数， G2 是从推荐列表中计算出的物品流行度的基尼系数，那么如果 G2 &gt; G1 ，就说明推荐算法具有马太效应。 2.4 其他常用指标多样性、新颖性（平均流行度）、惊喜度、信任度、实时性、健壮性、商业目标（销售额、广告点击量等） 2.5 离线优化目标对于可以离线优化的指标，我个人的看法是应该在给定覆盖率、多样性、新颖性等限制条件下，尽量优化预测准确度。用一个数学公式表达，离线实验的优化目标是：最大化预测准确度​ 使得 覆盖率 &gt; A​ 多样性 &gt; B​ 新颖性 &gt; C 其中， A 、 B 、 C 的取值应该视不同的应用而定。 3 评测维度一般来说，评测维度分为如下 3 种： 用户维度 主要包括用户的人口统计学信息、活跃度以及是不是新用户等。 物品维度 包括物品的属性信息、流行度、平均分以及是不是新加入的物品等。 时间维度 包括季节，是工作日还是周末，是白天还是晚上等。]]></content>
      <tags>
        <tag>推荐系统</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“今天你更博学了吗”系列（一）：夏虫不可语冰，井蛙不可语海]]></title>
    <url>%2F2018%2F12%2F07%2F2018-12-07-%E4%BB%8A%E5%A4%A9%E4%BD%A0%E6%9B%B4%E5%8D%9A%E5%AD%A6%E4%BA%86%E5%90%97%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%A4%8F%E8%99%AB%E4%B8%8D%E5%8F%AF%E8%AF%AD%E5%86%B0%EF%BC%8C%E4%BA%95%E8%9B%99%E4%B8%8D%E5%8F%AF%E8%AF%AD%E6%B5%B7%2F</url>
    <content type="text"><![CDATA[“今天你更博学了吗”系列（一）：夏虫不可语冰，井蛙不可语海1 达克效应达克效应（D-K effect），全称为邓宁-克鲁格效应（Dunning-Kruger effect），是一种认知偏差，能力欠缺的人有一种虚幻的自我优越感，错误地认为自己比真实情况更优秀。即庸人容易因欠缺自知之明而自我膨胀。 Kruger和Dunning将其归咎于元认知上的缺陷，能力欠缺的人无法认识到自身的无能，不能准确评估自身的能力。他们的研究还表明，反之，非常能干的人会低估自己的能力，错误地假定他们自己很容易完成的任务，别人也能够很容易完成。 他们因为这个研究，曾被授予2001年诺贝尔心理学奖。 “无知要比知识更容易产生自信”——达尔文。 达克效应图示： ​ 图片来源：小道消息文章“你的认知，大体上处于‘愚昧之山’上坡的地方” “吾生也有涯，而知也无涯，以有涯随无涯，殆已“——《庄子》 2 克苏鲁神话克苏鲁神话是一类恐怖题材，它的恐怖被称为“不可名状的恐怖”。 体系开创者：洛夫克拉夫特（H.P.Lovecraft，“爱手艺”老爷），他认为“人类最古老、最强烈的情感是恐惧；而最古老、最强烈的恐怖，是对未知的恐惧”。 在克苏鲁神话中，真正的主角是“旧日支配者”，人类的地位微不足道。 克鲁苏元素的表现形式： 电影（如著名科幻电影《异形》早期描述的是这样一种恐惧：有一只非常致命的怪物，无影无踪，往往惨叫一声，配角就少一个……） 深海恐惧：混沌、虚空等。 3 亿级数据中判断一个元素是否存在3.1 常规实现使用HashMap，会内存溢出。 3.2 Bloom Filter（布鲁姆过滤算法） 图示： （1）初始化一个指定大小（SIZE）的数组，用于标记数据 （2）对添加进的数据进行多次（图中是两次）hash算法，通过算出的hashcode值与SIZE值取模后定位在标记数组中，并设置该处值为1 （3）在数据添加完毕后，需要判断某个数是否存在：同样对该数进行多次hash算法，若三次hashcode值与SIZE值取模后定位点均标记为1，则表示该数存在，若存在一次非1，则表示该数不存在。 特点： 若判断出数据不存在，则一定不存在 若判断出数据存在，则大概率存在（有一定误报率） 同时不能清除其中的数据 自己代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class BloomFilter &#123; //标记数组大小 private int size; private int[] array; public BloomFilter(int size)&#123; this.size = size; array = new int[size]; &#125; /** * 判断一个数是否存在 * @param data * @return */ public boolean check(String data)&#123; int first = hashcode_1(data); int second = hashcode_2(data); int third = hashcode_3(data); if(array[first % size] == 1)&#123; return true; &#125; if(array[second % size] == 1)&#123; return true; &#125; if(array[third % size] == 1)&#123; return true; &#125; return false; &#125; /** * 添加数据 * @param key */ public void add(String key)&#123; int first = hashcode_1(key); int second = hashcode_2(key); int third = hashcode_3(key); array[first % size] = 1; array[second % size] = 1; array[third % size] = 1; &#125; public int hashcode_1(String key) &#123; int hash = 0; int i; for (i = 0; i &lt; key.length(); i++) &#123; hash = 33 * hash + key.charAt(i); &#125; return Math.abs(hash); &#125; /** * 乘法哈希，改进的FNV算法 * * @param key * @return */ public int hashcode_2(String key) &#123; final int p = 16777619; int hash = (int) 2166136261L; for (int i = 0; i &lt; key.length(); i++) &#123; hash = (hash ^ key.charAt(i)) * p; &#125; hash += hash &lt;&lt; 13; hash ^= hash &gt;&gt; 7; hash += hash &lt;&lt; 3; hash ^= hash &gt;&gt; 17; hash += hash &lt;&lt; 5; return Math.abs(hash); &#125; public int hashcode_3(String key) &#123; int hash, i; for (hash = 0, i = 0; i &lt; key.length(); i++)&#123; hash += key.charAt(i); hash += (hash &lt;&lt; 10); hash ^= (hash &gt;&gt; 6); &#125; hash += (hash &lt;&lt; 3); hash ^= (hash &gt;&gt; 11); hash += (hash &lt;&lt; 15); return Math.abs(hash); &#125;&#125; 测试： 123456789101112131415161718192021222324252627long start = System.currentTimeMillis(); BloomFilter bf = new BloomFilter(100000000); for (int i = 0; i &lt; 1000000000; i ++)&#123; bf.add(i + ""); &#125; if(bf.check(30 + ""))&#123; System.out.println("TRUE"); &#125;else&#123; System.out.println("FALSE"); &#125; if(bf.check( "skfskfknfksk"))&#123; System.out.println("TRUE"); &#125;else&#123; System.out.println("FALSE"); &#125; if(bf.check(90 + ""))&#123; System.out.println("TRUE"); &#125;else&#123; System.out.println("FALSE"); &#125; long end = System.currentTimeMillis(); System.out.println("执行时间：" + (end - start)); 存在问题：GC日志频繁，老年代使用率高。 3.3 Google Guava 库官方实现123456789101112131415/*** create(Funnel funnel, int expectedInsertions, double falsePositiveProbability)* 第一个参数10000000：预计存放多少数据* 第二个参数0.01：可接受的误报率*///BloomFilter&lt;Integer&gt; datas = BloomFilter.create(Funnels.integerFunnel(), 10000000, 0.01);BloomFilter&lt;Person&gt; friends = BloomFilter.create(personFunnel, 10000000, 0.01);for(Person friend : friendsList) &#123; friends.put(friend);&#125;if (friends.mightContain(dude)) &#123; //dude不是朋友还运行到这里的概率为1% //在这儿，我们可以在做进一步精确检查的同时触发一些异步加载&#125; Guava 会通过你预计的数量以及误报率帮你计算出你应当会使用的数组大小 numBits 以及需要计算几次 Hash 函数 numHashFunctions 。 算法详情参考：https://en.wikipedia.org/wiki/Bloom_filter Guava使用教程参考：https://www.yiibai.com/guava ​ http://ifeve.com/google-guava/]]></content>
      <tags>
        <tag>观感随笔</tag>
        <tag>技术随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop系列（三）：三大运行模式之完全分布式运行模式]]></title>
    <url>%2F2018%2F12%2F06%2F2018-12-06-Hadoop%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%B8%89%E5%A4%A7%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Hadoop系列（三）：三大运行模式之完全分布式运行模式1 虚拟机准备准备3台虚拟机，修改静态IP及主机名，并关闭防火墙。 2 环境配置2.1 scp（secure copy）安全拷贝 定义：scp可实现服务器与服务器之间的拷贝。 基本语法如下： 12345$ scp -r $pdir/$fname $user@hadoop$host:$pdir/$fname解释： -r ：递归 $pdir/$fname ：要拷贝的文件路径/名称 $user@hadoop$host:$pdir/$fname ：目的用户@主机:目的路径/名称 将JDK及Hadoop等软件拷贝到三台服务器中 123[sharehao@hadoop /]$ scp -r /opt root@hadoop01:/opt[sharehao@hadoop /]$ scp -r /opt root@hadoop02:/opt[sharehao@hadoop /]$ scp -r /opt root@hadoop03:/opt 注意：拷贝过来的/opt/module目录，别忘了在hadoop01、hadoop02、hadoop03上修改文件的所有者和所有者组。 1$ sudo chown sharehao:sharehao -R /opt 将环境变量配置文件拷贝到三台服务器中 123[sharehao@hadoop ~]$ sudo scp /etc/profile root@hadoop01:/etc/profile[sharehao@hadoop ~]$ sudo scp /etc/profile root@hadoop02:/etc/profile[sharehao@hadoop ~]$ sudo scp /etc/profile root@hadoop03:/etc/profile 2.2 rsync 远程同步工具 特点：rsync主要用于备份和镜像，具有速度快、避免复制相同内容和支持符号链接的优点。 与scp的区别：rsync复制文件要比scp的速度快，rsync只对差异文件做更新，而scp是把所有文件都复制过去。 语法： 1234567$ rsync -rvl $pdir/$fname $user@hadoop$host:$pdir/$fname解释： -r ：递归 -v ：显示复制过程 -l ：拷贝符号链接 $pdir/$fname ：要拷贝的文件路径/名称 $user@hadoop$host:$pdir/$fname ：目的用户@主机:目的路径/名称 案例演示： 把hadoop服务器上的/opt/software目录同步到hadoop01服务器的root用户下的/opt/software目录 1[sharehao@hadoop opt]$ rsync -rvl /opt/software/ root@hadoop01:/opt/software 2.3 xsync 集群分发脚本 用途：将某个服务器上的文件复制到其他多台服务器上 自己编写xsync.sh脚本： 12345678910111213141516171819202122232425#!/bin/bash#1 获取输入参数个数，如果没有参数，直接退出pcount=$#if((pcount==0)); thenecho no args;exit;fi#2 获取文件名称p1=$1fname=`basename $p1`echo fname=$fname#3 获取上级目录到绝对路径pdir=`cd -P $(dirname $p1); pwd`echo pdir=$pdir#4 获取当前用户名称user=`whoami`#5 循环for((host=103; host&lt;105; host++)); do echo ------------------- hadoop$host -------------- rsync -rvl $pdir/$fname $user@hadoop$host:$pdirdone 修改脚本执行权限 1$ chmod 777 xsync.sh 调用脚本 1$ ./xsync.sh /opt/software 3 集群配置3.1 集群部署规划 hadoop01 hadoop02 hadoop03 HDFS NameNode DataNode DataNode SecondaryNameNode DataNode YARN NodeManager ResourceManager NodeManager NodeManager 说明：NameNode、SecondaryNameNode 以及 ResourceManager 不能在同一台服务器上。 3.2 配置集群3.2.1 配置core-site.xml1234567891011&lt;!-- 指定HDFS中NameNode的地址 --&gt;&lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://hadoop01:9000&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定Hadoop运行时产生文件的存储目录 --&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop-2.7.2/data/tmp&lt;/value&gt;&lt;/property&gt; 3.2.2 配置HDFS配置文件 hdfs-env.sh 1export JAVA_HOME=/opt/jdk1.8.0_191 hdfs-site.xml 12345678910&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定Hadoop辅助名称节点主机配置 --&gt;&lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;hadoop03:50090&lt;/value&gt;&lt;/property&gt; 3.2.3 YARN配置文件 yarn-env.sh 1export JAVA_HOME=/opt/jdk1.8.0_191 yarn-site.sh 1234567891011&lt;!-- Reducer获取数据的方式 --&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定YARN的ResourceManager的地址 --&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;hadoop02&lt;/value&gt;&lt;/property&gt; 3.2.4 MapReduce配置文件 mapred-env.sh 1export JAVA_HOME=/opt/jdk1.8.0_191 mapred-site.xml 12#重命名$ cp mapred-site.xml.template mapred-site.xml 123456#增加配置&lt;!-- 指定MR运行在Yarn上 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt; 3.2.5 使用xsync分发配置文件1$ ./xsync.sh /opt/hadoop-2.7.2/ 3.3 启动集群3.3.1 单点启动 若第一次启动集群，则先格式化NameNode 1[sharehao@hadoop01 hadoop-2.7.2]$ hadoop namenode -format 在hadoop01上启动NameNode 1$ hadoop-daemon.sh start namenode 三台服务器均启动DataNode 1$ hadoop-daemon.sh start datanode 在hadoop02上启动ResourceManager 1$ yarn-daemon.sh start resourcemanager 三台服务器均启动NodeManager 1$ yarn-daemon.sh start nodemanager 在hadoop03上启动SecondaryNameNode 1$ hadoop-daemon.sh start secondarynamenode 3.3.2 群点启动 配置 slaves 文件 可以让DataNode、NodeManager一起在配置的服务器上启动。 1234#增添内容hadoop01hadoop02hadoop03 注意：该文件中添加的内容结尾不允许有空格，文件中不允许有空行。 同步所有节点配置文件 1$ ./xsync.sh slaves 启动集群 （1）若第一次启动集群，则需要格式化NameNode（格式化之前，一定要先停止上次启动的所有namenode和datanode进程，然后再删除data和logs数据） 1$ bin/hdfs namenode -format （2）启动HDFS 1$ sbin/start-dfs.sh （3）启动YARN（注：NameNode和ResourceManger如果不是同一台机器，不能在NameNode上启动 YARN，应该在ResouceManager所在的机器上启动YARN） 1$ sbin/start-yarn.sh 4 SSH无密登录配置4.1 实现原理 4.2 实操 配置SSH 1$ ssh ip地址 若连接出现Host key verification failed错误，直接输入yes即可。 ssh-key-gen生成公钥和私钥 1$ ssh-keygen -t rsa 敲三次回车即可。 将公钥拷贝到要免密登录的目标服务器上 123[sharehao@hadoop .ssh]$ ssh-copy-id hadoop01[sharehao@hadoop .ssh]$ ssh-copy-id hadoop02[sharehao@hadoop .ssh]$ ssh-copy-id hadoop03 注意： （1）需要在hadoop01上采用root账号，配置无密登录到hadoop01、hadoop02、hadoop03； （2）需要在hadoop02上采用sharehao账号，配置无密登录到hadoop01、hadoop02、hadoop03。 4.3 .ssh文件夹下（~/.ssh）的文件功能解释 known_hosts 记录ssh访问过计算机的公钥(public key) id_rsa 生成的私钥 id_rsa.pub 生成的公钥 authorized_keys 存放授权过得无密登录服务器公钥 5 集群时间同步5.1 基准服务器配置注：必须使用root用户 检查ntp是否安装 1$ rpm -qa|grep ntp 修改ntp配置文件 1$ vi /etc/ntp.conf （1）授权192.168.222.0-192.168.222.255网段上的所有机器可以从这台机器上查询和同步时间 123#restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap修改为：restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap （2）配置集群在局域网中，不使用其他互联网上的时间 123456789server 0.centos.pool.ntp.org iburstserver 1.centos.pool.ntp.org iburstserver 2.centos.pool.ntp.org iburstserver 3.centos.pool.ntp.org iburst修改为：#server 0.centos.pool.ntp.org iburst#server 1.centos.pool.ntp.org iburst#server 2.centos.pool.ntp.org iburst#server 3.centos.pool.ntp.org iburst （3）当该节点丢失网络连接，依然可以采用本地时间作为时间服务器为集群中的其他节点提供时间同步 123添加以下内容：server 127.127.1.0fudge 127.127.1.0 stratum 10 修改/etc/sysconfig/ntpd 文件 1234$ vim /etc/sysconfig/ntpd增加以下内容：（让硬件时间与系统时间一起同步）SYNC_HWCLOCK=yes 重新启动ntpd服务，并设置其开机启动 5.2 其他服务器配置注意：同样需要是root用户 配置每5分钟同步一次，使用crontab设置定时任务： 1$ crontab -e 编写如下定时任务： 1*/5 * * * * /usr/sbin/ntpdate hadoop01]]></content>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop系列（二）：三大运行模式之伪分布式运行模式]]></title>
    <url>%2F2018%2F12%2F05%2F2018-12-04-Hadoop%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%B8%89%E5%A4%A7%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Hadoop系列（二）：三大运行模式之伪分布式运行模式1 使用HDFS运行MapReduce程序官网地址：http://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-common/SingleCluster.html 配置HDFS文件系统后，则本地运行模式无法使用。 1.1 配置集群 配置hadoop-env.sh Linux系统中获取JDK的安装路径： 12$ echo $JAVA_HOME输出/opt/jdk1.8.0_191 修改JAVA_HOME 路径： 1export JAVA_HOME=/opt/module/jdk1.8.0_191 配置core-site.xml（NameNode） 1234567891011&lt;!-- 指定HDFS中NameNode的地址 --&gt;&lt;property&gt;&lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定Hadoop运行时产生文件的存储目录 --&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop-2.7.2/data/tmp&lt;/value&gt;&lt;/property&gt; 配置hdfs-site.xml 12345&lt;!-- 指定HDFS副本的数量 --&gt;&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt;&lt;/property&gt; 1.2 启动集群 格式化NameNode（第一次启动时格式化，不要总格式化） 1$ bin/hdfs namenode -format 格式化后生成data及logs目录 启动NameNode 1$ sbin/hadoop-daemon.sh start namenode 启动DataNode 1$ sbin/hadoop-daemon.sh start datanode 使用jps命令查看集群 1$ jps 注意：jps是JDK中的命令，不是Linux命令。若不安装JDK，则不能使用jps。 1.3 Web端查看HDFS文件系统​ IP地址：50070 1.4 操作集群 在HDFS文件系统创建input文件夹 1$ bin/hdfs dfs -mkdir -p /user/sharehao/input 将本地测试文件上传到input文件夹 1$ bin/hdfs dfs -put wcinput/wc.input /user/sharehao/input/ 查看上传的文件 1$ bin/hdfs dfs -ls /user/sharehao/input/ 运行MapReduce程序（保证HDFS文件系统中output目录不存在） 1$ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/sharehao/input/ /user/sharehao/output 查看输出结果 1$ bin/hdfs dfs -cat /user/sharehao/output/* 下载结果到本地 1$ hdfs dfs -get /user/sharehao/output/part-r-00000 ./wcoutput/ 1.5 遇到Bug则查看log日志（logs目录下）1$ cat hadoop-atguigu-datanode-hadoop101.log 1.6 注意事项为什么不能一直格式化NameNode，格式化NameNode的注意事项： 123456[sharehao@hadoop hadoop-2.7.2]$ cd data/tmp/dfs/name/current/[sharehao@hadoop current]$ cat VERSIONclusterID=CID-f0330a58-36fa-4a2a-a65f-2688269s54m1[sharehao@hadoop hadoop-2.7.2]$ cd data/tmp/dfs/data/current/clusterID=CID-f0330a58-36fa-4a2a-a65f-2688269s54m1 格式化NameNode，会产生新的集群id，导致NameNode和DataNode的集群id不一致，集群找不到已往数据。因此，格式NameNode时，一定要先删除data数据和log日志，然后再格式化NameNode。 2 使用YARN运行MapReduce程序2.1 配置集群 配置yarn-env.sh 修改JAVA_HOME： 1export JAVA_HOME=/opt/jdk1.8.0_191 配置yarn-site.xml 1234567891011&lt;!-- Reducer获取数据的方式 --&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定YARN的ResourceManager的地址 --&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;master&lt;/value&gt;&lt;/property&gt; 配置mapred-env.sh 修改JAVA_HOME： 1export JAVA_HOME=/opt/jdk1.8.0_191 配置 (对mapred-site.xml.template重新命名为) mapred-site.xml 12345&lt;!-- 指定MR运行在YARN上 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt; 2.2 启动集群 保证NameNode和DataNode已经启动 启动ResourceManager 1$ sbin/yarn-daemon.sh start resourcemanager 启动NodeManager 1$ sbin/yarn-daemon.sh start nodemanager 2.3 操作集群 Web端查看 http://IP地址或主机名:8088/cluster 删除文件系统上的output文件 1$ bin/hdfs dfs -rm -R /user/sharehao/output 执行MapReduce程序 1$ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/sharehao/input /user/sharehao/output 在Web端可查看运行结果 2.4 配置历史服务器 配置mapred-site.xml 12345678910&lt;!-- 历史服务器端地址 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;master:10020&lt;/value&gt;&lt;/property&gt;&lt;!-- 历史服务器web端地址 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;master:19888&lt;/value&gt;&lt;/property&gt; 启动历史服务器 1$ sbin/mr-jobhistory-daemon.sh start historyserver 2.5 配置日志的聚集即应用运行完成以后，将程序运行日志信息上传到HDFS系统上。方便查看到程序运行详情，且方便开发调试。 注意：开启日志聚集功能，需要重新启动NodeManager 、ResourceManager和HistoryManager。 配置yarn-site.xml 1234567891011&lt;!-- 日志聚集功能使能 --&gt;&lt;property&gt;&lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;!-- 日志保留时间设置7天 --&gt;&lt;property&gt;&lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;&lt;value&gt;604800&lt;/value&gt;&lt;/property&gt; 关闭NodeManager 、ResourceManager和HistoryManager 123$ sbin/yarn-daemon.sh stop resourcemanager$ sbin/yarn-daemon.sh stop nodemanager$ sbin/mr-jobhistory-daemon.sh stop historyserver 启动NodeManager 、ResourceManager和HistoryManager 2.6 配置文件的说明Hadoop配置文件分两类：默认配置文件和自定义配置文件，只有用户想修改某一默认配置值时，才需要修改自定义配置文件，更改相应属性值。 默认配置文件，如下表： 要获取的默认文件 文件存放在Hadoop的jar包中的位置 [core-default.xml] hadoop-common-2.7.2.jar/ core-default.xml [hdfs-default.xml] hadoop-hdfs-2.7.2.jar/ hdfs-default.xml [yarn-default.xml] hadoop-yarn-common-2.7.2.jar/ yarn-default.xml [mapred-default.xml] hadoop-mapreduce-client-core-2.7.2.jar/ mapred-default.xml 自定义配置文件： core-site.xml、hdfs-site.xml、yarn-site.xml、mapred-site.xml四个配置文件存放在$HADOOP_HOME/etc/hadoop这个路径上，用户可以根据项目需求重新进行修改配置。]]></content>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop系列（一）：Hadoop运行环境搭建及本地运行模式]]></title>
    <url>%2F2018%2F12%2F05%2F2018-12-04-Hadoop%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHadoop%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Hadoop系列（一）：Hadoop运行环境搭建及本地运行模式1 Hadoop运行环境搭建1.1 准备虚拟机运行环境 克隆虚拟机 修改克隆虚拟机的静态IP及主机名 关闭防火墙（让外网可以访问） 创建一个用户（如sharehao），并配置其拥有root权限 1.2 安装JDK（1.7以上） 查询JDK版本 1$ rpm -qa | grep java 若JDK版本低于1.7，则卸载： 1$ sudo rpm -e 软件包 安装新的JDK 1.3 安装Hadoop 下载地址 https://archive.apache.org/dist/hadoop/common/hadoop-2.7.2/ 使用xftp或SecureCRT工具将下载的hadoop上传到/opt目录 解压到指定目录 添加环境变量 （1）编辑/etc/profile 1$ sudo vi /etc/profile （2）配置Hadoop 1234##HADOOP_HOMEexport HADOOP_HOME=/opt/hadoop-2.7.2 #Hadoop解压路径export PATH=$PATH:$HADOOP_HOME/binexport PATH=$PATH:$HADOOP_HOME/sbin （3）让修改的文件生效 1$ source /etc/profile 测试是否配置成功 1$ hadoop version 1.4 Hadoop目录结构 bin目录：存放对Hadoop相关服务（HDFS，YARN）进行操作的脚本 etc目录：Hadoop的配置文件目录，存放Hadoop的配置文件 lib目录：存放Hadoop的本地库（对数据进行压缩解压缩功能） sbin目录：存放启动或停止Hadoop相关服务的脚本 share目录：存放Hadoop的依赖jar包、文档、和官方案例 2 本地运行模式hadoop官网：http://hadoop.apache.org/ 对照着官网文档一步步配置即可使用：http://hadoop.apache.org/docs/r2.7.2/ 2.1 官方Grep案例 创建在hadoop-2.7.2文件下面创建一个input文件夹 1$ mkdir input 将Hadoop的xml配置文件复制到input 1$ cp etc/hadoop/*.xml input 执行share目录下的MapReduce程序（保证output目录不存在） 1$ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar grep input output 'dfs[a-z.]+' 查看输出结果 1$ cat output/* 2.2 官方WordCount案例 创建在hadoop-2.7.2文件下面创建一个wcinput文件夹 1$ mkdir wcinput 在wcinput文件下创建一个wc.input文件 12$ cd wcinput$ touch wc.input 编辑wc.input文件，输入单词内容 1$ vim wc.input 回到Hadoop目录/opt/hadoop-2.7.2 执行程序 1$ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount wcinput wcoutput 查看结果 1$ cat wcoutput/part-r-00000 3 关于Linux操作防火墙的相关命令3.1 firewalld的基本使用CentOS7使用systemctl替换了service和chkconfig 12345启动： systemctl start firewalld关闭： systemctl stop firewalld查看状态： systemctl status firewalld 开机禁用 ： systemctl disable firewalld开机启用 ： systemctl enable firewalld 3.2 使用systemctl做服务管理123456789启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl --failed 3.3 配置firewalld-cmd12345678910查看版本： firewall-cmd --version查看帮助： firewall-cmd --help显示状态： firewall-cmd --state查看所有打开的端口： firewall-cmd --zone=public --list-ports更新防火墙规则： firewall-cmd --reload查看区域信息: firewall-cmd --get-active-zones查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0拒绝所有包：firewall-cmd --panic-on取消拒绝状态： firewall-cmd --panic-off查看是否拒绝： firewall-cmd --query-panic 3.4 防火墙开放端口1234添加：firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效）重新载入：firewall-cmd --reload查看：firewall-cmd --zone= public --query-port=80/tcp删除：firewall-cmd --zone= public --remove-port=80/tcp --permanent 参考资料：CentOS7使用firewalld打开关闭防火墙与端口]]></content>
      <tags>
        <tag>hadoop</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot系列（五）：Web开发之国际化与拦截器]]></title>
    <url>%2F2018%2F11%2F16%2F2018-11-16-Spring-Boot%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AWeb%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9B%BD%E9%99%85%E5%8C%96%E4%B8%8E%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Spring Boot系列（五）：Web开发之国际化与拦截器1 国际化1.1 一般开发步骤 编写国际化配置文件； 使用ResourceBundleMessageSource管理国际化资源文件 在页面使用fmt:message取出国际化内容 1.2 编写国际化配置文件 创建国际化配置文件，存入如下文件格式： 抽取页面上需要国际化显示的内容，在Spring Boot中可以使用如下方式开发： 在application.properties中修改国际化文件访问路径 12#修改国际化配置文件的路径及基础访问名 默认为类路径下messagesspring.messages.basename=i18n.login 原理： 1234567891011@ConfigurationProperties(prefix = "spring.messages")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * "org.mypackage"), it will be resolved from the classpath root. */ private String basename = "messages"; //我们的配置文件可以直接放在类路径下叫messages.properties； 1.3 使用Thymeleaf在页面获取国际化的值使用#{…} ： 1234使用#&#123;...&#125;获取国际化参数值&lt;div class="layui-card-header" th:text="#&#123;login.title&#125;"&gt; &lt;i class="layui-icon layui-icon-engine"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;用户登录&lt;/div&gt; 1.4 实现超链接转换国际化 页面上传入国家语言参数 1234&lt;p&gt; &lt;span&gt;&lt;a href="" th:href="@&#123;/login.html(lang=zh_CN)&#125;"&gt;中文&lt;/a&gt;&lt;/span&gt; &lt;span&gt;&lt;a href="" th:href="@&#123;/login.html(lang=en_US)&#125;"&gt;English&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 编写自定义国际化组件，并将组件添加到容器 ① 自定义国际化组件（实现LocaleResolver接口） 12345678910111213141516171819202122public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123; String lang = httpServletRequest.getParameter("lang");// System.out.println(lang); //若没有传入参数，则使用默认的 Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(lang))&#123; String[] langs = lang.split("_"); locale = new Locale(langs[0], langs[1]);// System.out.println(langs[0] + langs[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123; &#125;&#125; ② 将组件添加到容器 12345678910@Configurationpublic class MyConfiguration implements WebMvcConfigurer &#123; //添加国际化解析组件 @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 2 拦截器（以登陆检查为例）2.1 编写拦截器组件自定义拦截器类实现HandlerInterceptor接口即可： 1234567891011121314public class LoginHandlerInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123; Object user = request.getSession().getAttribute("loginUser"); if(user == null)&#123; request.setAttribute("msg","没有权限请先登陆"); request.getRequestDispatcher("/index.html").forward(request,response); return false; &#125;else &#123; return true; &#125; &#125;&#125; 2.2 将组件添加到容器1234567891011121314151617@Configurationpublic class MyConfiguration implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //super.addViewControllers(registry); //将某个请求映射到某个页面，但是不会经过Controller registry.addViewController("/").setViewName("/login"); registry.addViewController("/index.html").setViewName("/login"); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; //访问登录页不拦截，登录时的URI不拦截 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**").excludePathPatterns("/","/index.html","/user/login"); &#125;&#125; 注意：启用自定义登录拦截器后往往无法访问静态资源，这是因为Spring Boot自动配置的静态资源映射默认为“/**”，而我们编写的登录拦截器需要拦截除少数页面的所有页面（如上述代码所示），因此我们需要修改静态资源映射路径，并在登录拦截器中排除。 解决： 在application.properties中修改静态资源映射路径 1spring.mvc.static-path-pattern= /static/** 在登录拦截器中排除掉静态资源映射路径 1234@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**").excludePathPatterns("/","/index.html","/user/login","/static/**");&#125;]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot系列（四）：Web开发之基础入门]]></title>
    <url>%2F2018%2F11%2F16%2F2018-11-16-Spring-Boot%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AWeb%E5%BC%80%E5%8F%91%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Spring Boot系列（四）：Web开发之基础入门1 Spring Boot的Web开发步骤 创建SpringBoot应用，选中我们需要的模块 SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行 编写业务逻辑代码 复习Spring Boot的自动配置原理： xxxAutoConfiguration：给容器中自动配置组件； xxxProperties：配置类来封装配置文件的内容； 2 Spring Boot对静态资源的映射规则2.1 源码解析123@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 WebMvcAuotConfiguration： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler("/webjars/**") .addResourceLocations( "classpath:/META-INF/resources/webjars/") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 getStaticLocations() if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125;&#125; //配置欢迎页映射@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern());&#125; //配置喜欢的图标@Configuration@ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true)public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125;&#125; 2.2 源码结论 所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源 webjars：以jar包的方式引入静态资源；引入webjars 直接在pom.xml中以dependency形式引入即可： 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; 引入后可以看到其目录结构如下： 项目运行后，可通过localhost:8080/webjars/jquery/3.3.1/jquery.js访问到静态资源。 静态资源默认映射地址为 “/”**，去静态资源文件夹找映射，有如下五种： 12345"classpath:/META-INF/resources/", "classpath:/resources/","classpath:/static/", "classpath:/public/" "/"：当前项目的根路径 例如：localhost:8080/index.html 是去上述静态资源文件夹里面找index.html 欢迎页：静态资源文件夹下的所有index.html页面，被”/**”映射 例如： 访问localhost:8080/ 会找index.html页面 网站图标：所有的 **/favicon.ico 都是在静态资源文件下找 3 SpringMVC自动配置详情访问Spring Boot官网关于The ‘Spring Web MVC framework’ 3.1 自动配置SpringMVC的组件详解（对照官网） Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（如转发或重定向）） ContentNegotiatingViewResolver：组合所有的视图解析器的 定制ViewResolver：我们可以自己给容器中添加一个视图解析器，自动的将其组合进来。 Support for serving static resources, including support for WebJars (see below) ：静态资源文件夹路径，webjars Static index.html support. ：静态首页访问 Custom Favicon support (see below). ：图标favicon.ico Automatic registration of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter ：格式化器； 2018.11.16 ——- &gt; Date； 12345@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; Support for HttpMessageConverters (see below).：SpringMVC用来转换Http请求和响应的，User—Json Automatic registration of MessageCodesResolver (see below). ：定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below).：初始化WebDataBinder，请求数据转换为JavaBean 3.2 扩展SpringMVC 传统扩展SpringMVC方法（在配置文件中编写） 1234567&lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;success&quot;/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot;/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 在Spring Boot中扩展SpringMVC 首先，编写一个配置类@Configuration； 其次，继承WebMvcConfigurer，但不能标注@EnableWebMvc； 这样，我们既能保留自动配置的SpringMVC，自己扩展的组件也能起作用。 12345678910@Configurationpublic class MyConfiguration implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //将某个请求映射到某个页面，但是不会经过Controller registry.addViewController("/").setViewName("/login"); registry.addViewController("/index.html").setViewName("/login"); &#125;&#125; 3.3 全面接管SpringMVC在我们编写的配置类上标注@EnableWebMvc即可。 123@EnableWebMvc //全面接管Spring MVC@Configurationpublic class MyConfiguration implements WebMvcConfigurer &#123; 原理： 1）通过进入@EnableWebMvc可知，@EnableWebMvc的核心如下： 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 即导入了DelegatingWebMvcConfiguration。 2）而DelegatingWebMvcConfiguration继承自WebMvcConfigurationSupport： 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）通过进入WebMvcAutoConfiguration可知： 12345678@Configuration@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)表明当没有WebMvcConfigurationSupport时才生效。 4 总结：修改Spring Boot默认配置的方法 SpringBoot在自动配置很多组件的时候，先看容器中有没有用户配置的（@Bean、@Component）： 如果有，就用用户配置的； 如果没有，才自动配置； 如果有些组件可以有多个（如ViewResolver），则将用户配置的和默认配置组合起来 在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot系列（三）：Thymeleaf的使用]]></title>
    <url>%2F2018%2F11%2F15%2F2018-11-15-Spring-Boot%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AThymeleaf%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Spring Boot系列（三）：Thymeleaf的使用1 关于模板引擎常见的模板引用有：JSP、Velocity、Freemarker、Thymeleaf 模板引擎作用如下图所示： 即将Controller层放置的数据动态显示在View层。 SpringBoot推荐使用Thymeleaf：语法更简单，功能更强大。 2 关于Thymeleaf2.1 引入Thymeleaf1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 切换 thymeleaf 版本： 123456&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 2.2 Thymeleaf 的使用1234567891011@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html"); public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; // 我们只需要把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染。 具体使用： 导入thymeleaf的名称空间（编写代码时自动提示） 1&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; 使用thymeleaf 语法 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.3 Thymeleaf 语法规则 th：任意html属性；来替换原生属性的值： 表达式 ① ${…}：获取变量值；OGNL 获取对象的属性、调用方法 使用内置的基本对象 123456789#ctx : the context object.#vars: the context variables.#locale : the context locale.#request : (only in Web Contexts) the HttpServletRequest object.#response : (only in Web Contexts) the HttpServletResponse object.#session : (only in Web Contexts) the HttpSession object.#servletContext : (only in Web Contexts) the ServletContext object.如：$&#123;session.foo&#125; 使用内置的一些工具对象 12345678910111213141516#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). ② *{…}：选择表达式：和${…}在功能上是一样 123456补充：配合 th:object="$&#123;session.user&#125;： &lt;div th:object="$&#123;session.user&#125;"&gt; &lt;p&gt;Name: &lt;span th:text="*&#123;firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text="*&#123;lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text="*&#123;nationality&#125;"&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; ③ #{…}：获取国际化内容 ④ @{…}：定义URL 1@&#123;/order/process(execId=$&#123;execId&#125;,execType='FAST')&#125; ⑤ ~{…}：片段引用表达式 1&lt;div th:insert="~&#123;commons :: main&#125;"&gt;...&lt;/div&gt; ⑥ 其他： 123456789101112131415161718192021222324Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 更多详细用法参见：官方文档。 为方便查看，这里笔者提供一个中文翻译文档， 提取码：jjf8 。]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot系列（二）：集成日志框架]]></title>
    <url>%2F2018%2F11%2F15%2F2018-11-15-Spring-Boot%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%9B%86%E6%88%90%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Spring Boot系列（二）：集成日志框架1 日志框架1.1 市面上的日志框架市面上目前使用的日志框架有：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 日志门面和日志实现的关系类似于JDBC和各个数据库； SpringBoot：底层是Spring框架，Spring框架默认是用JCL； Spring Boot 选用SLF4j和logback。 1.2 SLF4j使用 开发中使用SLF4j参考官网https://www.slf4j.org 开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法。 ①给系统里面导入slf4j的jar和 logback的实现jar； ②代码示例： 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 图解日志框架 如上图所示，若某一个日志实现框架不能直接使用SLF4j，则利用一个中间适配层，向上能契合SLF4j，向下又能适配该日志实现框架，从而间接实现SLF4j。 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件。 统一日志记录很多框架本身都有自己的日志记录框架，如Spring（commons-logging）、Hibernate（jboss-logging）等。 如何在集成其他框架后统一使用SLF4j输出呢？其原理如下图所示： 解释：当集成的很多框架都有自己的日志框架时，都提供一个slf4j-api.jar来统一适配其他日志，而其他日志也都使用一个适配层来代替（如jcl-over-slf4j.jar代替commons-logging.jar等），然后再根据具体的日志实现框架看是否需要适配层（如log4j日志框架在实现SLF4j时需要使用slf4j-log412.jar来适配）。 那在开发时如何在系统中统一使用SLF4j呢？ ① 将系统中其他日志框架先排除出去 ② 用中间包来替换原有的日志框架 ③ 导入slf4j其他的实现 2 Spring Boot日志框架原理2.1 Spring Boot日志关系Spring Boot使用如下依赖包实现日志功能： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 其底层依赖关系如下图所示（在IDEA中通过右击pom.xml，右击 —&gt; Diagrams —&gt; Show Dependencies）： 由上述关系可知： ① Spring Boot底层使用slf4j+logback的方式进行日志记录 ② Spring Boot通过一些中间转换包将其他的日志都替换成了slf4j 上图可以看到，jcl-over-slf4j实际上就是commons-logging日志框架，只是能够适配slf4j了。 2.2 Spring Boot引入其他框架时做的事情Spring Boot引入其他框架时需要把这个框架默认的日志依赖移除。 例如，在引入Spring框架时，需要将commons-logging排除掉： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 3 开发中日志的使用3.1 默认配置1234567891011121314151617//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志..."); &#125; 123456789日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符--&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n 3.2 修改默认配置在application.properties设置参数值即可： 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file 和 logging.path的区别： logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 3.3 指定配置自己编写好日志配置文件后，放在类路径下即可。此时SpringBoot就不使用默认配置了。 指定配置不同日志框架时，命名规则如下表： Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml 与 logback-spring.xml 的区别： logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能，如： 1234&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 12345678910111213141516171819&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;springProfile name="dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name="!dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt;&lt;/appender&gt; 推荐使用 logback-spring.xml。 3.4 切换日志框架按照slf4j的日志适配图（上文统一日志原理图），进行相关的切换。 3.4.1 将log-back日志切换为log4j 排除log-back日志依赖（可直接在pom.xml生成的依赖图上排除） 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 引入log4j适配层（该适配层依赖log4j） 1234&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 3.4.2 将spring-boot-starter-logging切换为spring-boot-starter-log4j2spring-boot-starter-logging和spring-boot-starter-log4j2，两者二选一。 排除spring-boot-starter-logging 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 引入spring-boot-starter-log4j2 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot系列（一）：第一个Spring Boot程序及精髓详解]]></title>
    <url>%2F2018%2F11%2F15%2F2018-11-15-Spring-Boot%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AASpring-Boot%E7%A8%8B%E5%BA%8F%E5%8F%8A%E7%B2%BE%E9%AB%93%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring Boot系列（一）：第一个Spring Boot程序及精髓详解1 第一个Spring Boot 程序构建步骤1.1 环境准备 JDK1.8：Spring Boot 推荐jdk1.7及以上； Maven3.x：maven 3.3以上版本；（在IDEA中配置好Maven） Spring Boot2.1.0.RELEASE 1.2 Hello World 创建一个Maven项目 导入Spring Boot 相关依赖 123456789101112131415161718192021222324&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;!-- Add typical dependencies for a web application --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- Package as an executable jar 简化部署，可将项目应用打包成jar--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 创建主程序 123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; //启动Spring Boot程序 SpringApplication.run(MainApplication.class, args); &#125;&#125; 编写Controller（注意：主程序类必须与Controller同包，或在其直接父包） 12345678910@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World"; &#125;&#125; 运行主程序，可能出现端口被占用错误，则可以在resource文件夹（类路径）下创建配置文件application.properties，修改访问端口，具体文件目录读者可以参考如下： 访问http://localhost:8181/hello ，即可看到响应的“Hello World”。 2 详解Hello World2.1 POM文件 父项目 1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;上述配置的父项目如下（可通过Ctrl+鼠标左键查看父项目）：&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； 因此上述配置是Spring Boot的版本仲裁中心。 启动器 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景的启动器。 2.2 主程序@SpringBootApplication注解@SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用。 通过Ctrl+鼠标左键点击进入@SpringBootApplication，其本质如下： 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration：Spring Boot的配置类，标注在某个类上，表示这是Spring Boot的一个配置类； 再次Ctrl+鼠标左键点击进入@SpringBootConfiguration，本质如下： 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123;&#125; @Configuration：配置类上来标注这个注解（Spring的底层注解）； ① 一个配置类相当于是一个配置文件 ② 配置类也是容器的一个组件（@Configuration底层用@Component标记） @EnableAutoConfiguration：开启自动配置功能。 以前我们需要配置的东西，Spring Boot帮我们自动配置，使用@EnableAutoConfiguration告诉Spring Boot开启自动配置功能，这样自动配置才能生效。 进入@EnableAutoConfiguration，其本质如下： 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; @AutoConfigurationPackage：自动配置包。 @Import(AutoConfigurationImportSelector.class)：Spring的底层注解@Import，给容器中导入一个组件；导入的组件有AutoConfigurationPackages.Registrar.class。 进入AutoConfigurationImportSelector类，其selectImports()方法将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。（可通过在selectImports()方法处设置断点查看返回的自动配置类(xxxAutoConfiguration)） 底层代码： 123456789protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames( getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you " + "are using a custom packaging, make sure that file is correct."); return configurations;&#125; SpringFactoriesLoader.loadFactoryNames()：Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值（即getSpringFactoriesLoaderFactoryClass()的返回值），将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。 3 使用Spring Initializer快速创建Spring Boot项目3.1 IDEA：使用 Spring Initializer快速创建项目 选择我们需要的模块，向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要编写自己的逻辑代码 resources文件夹中目录结构 ​ static：保存所有的静态资源； js css images； ​ templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页 面）；可以使用模板引擎（freemarker、thymeleaf）； ​ application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 3.2 STS使用 Spring Starter Project快速创建项目4 Spring Boot精髓4.1 配置文件注入 @ConfigurationProperties ① 配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 ② javaBean 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了，如下： 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; @Value获取值和@ConfigurationProperties获取值比较 | | @ConfigurationProperties | @Value || ————— | ———————————— | ——— || 功能 | 批量注入配置文件中的属性 | 一个个指定 || 松散绑定（松散语法） | 支持 | 不支持 || SpEL | 不支持 | 支持 || JSR303数据校验 | 支持 | 不支持 || 复杂类型封装 | 支持 | 不支持 | 关于@Value和@ConfigurationProperties的使用情况 在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 专门编写了一个javaBean来和配置文件进行映射，使用@ConfigurationProperties； 配置文件注入数据校验 123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4.2 关于配置文件及组件注入的几个注解 @PropertySource：加载指定的配置文件；（可将配置文件与主配置文件application.properties分离开来） 1234567891011121314151617181920@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")//@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；若想让Spring的配置文件生效，加载进来，则使用@ImportResource标注在一个配置类（如主配置类）上。 12@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)//导入Spring的配置文件让其生效 但上述做法不推荐使用，Spring Boot 推荐给容器中添加组件的方式，推荐使用全注解的方式，因此引入@Bean注解。 @Bean：给容器添加组件； 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); &#125;&#125; 4.3 配置文件占位符 随机数 12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 占位符获取之前配置的值，若没有可指定默认值 123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 4.4 自动配置原理 SpringBoot启动的时候加载主配置类，开启了自动配置功能（@EnableAutoConfiguration） @EnableAutoConfiguration 作用： 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 将类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中 每一个自动配置类进行自动配置功能 以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理： 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效。一但这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的。 由上述原理，引出以下精髓。 4.5 精髓 SpringBoot启动会加载大量的自动配置类 我们首先看我们需要的功能有没有SpringBoot默认写好的自动配置类； 再看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件在其中，则不需要进行配置） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。从而我们可以在配置文件中指定这些属性的值。 关于一些细节： @Conditional派生注解：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 另外，可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效。 5 Profile5.1 多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 5.2 yml支持多文档块方式12345678910111213141516171819server: port: 8081spring: profiles: active: prod #激活指定环境---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 5.3 激活指定Profile的方式 在配置文件中指定 spring.profiles.active=dev 命令行： java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； 可以直接在测试的时候，配置传入命令行参数 虚拟机参数； -Dspring.profiles.active=dev 6 配置文件加载位置6.1 内部文件加载顺序springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件： –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件，互补配置； 另外， 我们可以通过spring.config.location来改变默认的配置文件位置。 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置： java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 6.2 外部文件加载顺序SpringBoot也可以从以下位置加载配置， 优先级从高到低，高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置。 命令行参数 所有的配置都可以在命令行上进行指定： java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开， 配置项=值。 来自java:comp/env的JNDI属性 Java系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找；优先加载带profile jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ​ 再来加载不带profile jar包外部的application.properties或application.yml(不带spring.profile)配置文件 jar包内部的application.properties或application.yml(不带spring.profile)配置文件 @Configuration注解类上的@PropertySource 通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源请参考官方文档。]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo next主题搭建自己的个人博客及美化]]></title>
    <url>%2F2018%2F11%2F14%2F2018-11-14-Hexo-next-%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Hexo next主题搭建自己的个人博客及美化笔者的博客示例：https://hackxiehao.github.io/ ，欢迎各位大佬Star。 1 部署Hexo1.1 下载安装Node.js安装目的：方便后续使用npm命令下载Hexo及一些常用的库 Node.js官网下载：https://nodejs.org/en/ 下载成功界面如下： 1.2 下载安装Git由于hexo博客都是基于Git的，因此需要有Git环境。 Git官网下载：https://git-scm.com/downloads 下载成功后，鼠标右击桌面出现如下效果： 1.3 在Github上创建仓库 仓库命名需要符合规则：yourGithubName.github.io 将网址部署在网络上：在该仓库目录上点击settings，找到如下界面 选择Change theme，任意选择一个保存即可，https://yourGithubName.github.io 将作为你的博客网址。 1.4 安装Hexo 在电脑合适地方创建一个空目录，用于存储博客文件，例如： 在该目录下执行命令：npm install hexo -g 安装成功检查：hexo -v ，若出现如下信息则安装成功： 继续执行指令：hexo init ，初始化信息，初始化后该目录下有如下文件（有些文件是在执行后续命令后添加，如public文件夹等）： 执行指令：npm install ，安装所需组件； 执行指令：hexo g ，生成静态网页（public文件夹）； 执行指令：hexo s ，部署本地网站： 访问 http://localhost:4000 即可，若想修改端口，则可以使用指令：hexo server -p “portNumber” 最后，关于Hexo的详细信息，可以查看 Hexo官网文档 2 使用next主题next主题使用文档：http://theme-next.iissnan.com/ 2.1 next主题安装在博客根目录下，执行指令： 1git clone https://github.com/theme-next/hexo-theme-next themes/next 2.2 next主题美化2.2.1 将默认主题修改为next主题找到站点目录下的_config.yml文件，修改theme值为next： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 2.2.2 本地修改提交到Github 修改站点目录下的_config.yml文件，找到deploy： 1234deploy: type: git repository: git@github.com:HackXieHao/HackXieHao.github.io.git branch: master 其中repository的值，如果Github有SSH key，则形如上式值，如无则使用https。 博客根目录输入指令，hexo d，则将本地同步到Github。（一般使用该指令前，最好重新生成网页，即执行hexo g指令） 同步后，即可使用 https://yourGithubName.github.io 访问自己修改的博客。 2.2.3 主题菜单模式选择进入next主题的配置文件_config.yml，找到scheme，默认使用Muse，我这儿修改为Pisces： 12345# Schemes# scheme: Muse# scheme: Mistscheme: Pisces#scheme: Gemini 2.2.4 菜单目录设置进入next主题的配置文件_config.yml，找到menu，自定义菜单： 12345678menu: home: / || home tech: /tech/ || book life: /life/ || edit tags: /tags/ || tags # categories: /categories/ || th archives: /archives/ || archive about: /about/ || user 其中 /tech/ 表示该目录内容的存放文件夹，“||” 后如home等是用来设置图标，源自Font Awesome中图标的名字。 2.2.5 设置背景图片进入theme/next/source/css/_custom/custom.styl文件，配置如下： 1body &#123;background-image: url(/images/background.jpg);&#125; 其中的images目录是指theme/next/source/images。 2.2.6 设置首页不显示全文，只显示预览进入next主题配置文件_config.yml，找到auto_excerpt： 123456# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.# 设置首页文章预览效果auto_excerpt: enable: true length: 150 2.2.7 添加busuanzi统计（访问人数和访问总量的统计）关于busuanzi统计效果，读者可以先按照官方next文档配置，若存在问题则可对照笔者的解决方案。 笔者按照官方next文档配置无果后（不知道是不是next主题版本原因），历经千辛万苦，终于找到解决方案，在next主题配置文件_config.yml中找到busuanzi_count： 12345678910111213141516busuanzi_count: enable: true # total_visitors: true # total_visitors_icon: user # total_views: true # total_views_icon: eye post_views: true post_views_icon: eye # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问人数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 访问总量 site_pv_footer: 次 将Github上的next主题busuanzi源文件与自己本地的busuanzi源文件（themes/next/layout/_third-party/analytics/busuanzi-counter.swig）对比发现，源文件中设置的参数字段不同，按照官网源文件修改即可。 最后，在themes/next/layout/_partials/footer.swig中注释掉原来的显示代码： 123456789101112131415&#123;% if theme.footer.powered.enable %&#125;&lt;!-- &lt;div class="powered-by"&gt; &lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt;--&gt; &lt;!-- &lt;div class="powered-by"&gt;&#123;# #&#125;&#123;&#123; __('footer.powered', next_url('https://hexo.io', 'Hexo', &#123;class: 'theme-link'&#125;)) &#125;&#125;&#123;# #&#125;&#123;% if theme.footer.powered.version %&#125; v&#123;&#123; hexo_env('version') &#125;&#125;&#123;% endif %&#125;&#123;# #&#125;&lt;/div&gt; --&gt;&#123;% endif %&#125; 2.2.8 代码块复制功能 在clipboardjs官网下载clipboard.js / clipboard.min.js，保存到themes/next/source/js/src ; 新建文件clipboard-use.js，代码如下： 1234567891011121314151617/*页面载入完成后，创建复制按钮*/!function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; copyHtml += ' &lt;i class="fa fa-globe"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; initCopyCode(); &#125;(window, document); 在目录themes/next/source/css/_custom/custom.styl样式文件中添加如下代码 ： 123456789101112131415161718192021222324252627282930313233343536//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125; 在themes/next/layout/_layout.swig文件\前中引入JS： 123 &lt;!-- 代码块复制功能 --&gt;&lt;script type="text/javascript" src="/js/src/clipboard.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/clipboard-use.js"&gt;&lt;/script&gt; 2.2.9 在发表的文章中添加图片 修改站点配置文件_config.yml，设置post_asset_folder为true； 在博客根目录下执行如下指令安装插件： 1npm install https://github.com/CodeFalling/hexo-asset-image -- save 在使用 hexo new “title”创建文件时，会同时创建一个title同名文件夹用于存储图片，在对应的文章中使用![示例图片](title/example.PNG &quot;示例图片&quot;) 添加图片 3 参考资料更多next配置及美化，可参考如下链接： hexo的next主题个性化教程：打造炫酷网站 next主题官方文档]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 入门]]></title>
    <url>%2F2018%2F11%2F12%2FSpring%20Boot%2F</url>
    <content type="text"><![CDATA[一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备http://www.gulixueyuan.com/ 谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 ——- 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")//@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.atguigu.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration———&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); &#125;&#125; 4、配置文件占位符1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar —spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar —spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar —server.port=8087 —server.context-path=/abc 多个配置用空格分开； —配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ​ ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = "spring.http.encoding") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—-数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings("rawtypes")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = "http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志...");&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;springProfile name="dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name="!dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler("/webjars/**") .addResourceLocations( "classpath:/META-INF/resources/webjars/") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html"); public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico ​ 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—-Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== ​ Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path="/hello" view-name="success"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/hello"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = "spring.messages")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * "org.mypackage"), it will be resolved from the classpath root. */ private String basename = "messages"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="asserts/css/bootstrap.min.css" th:href="@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="asserts/css/signin.css" th:href="@&#123;/asserts/css/signin.css&#125;" rel="stylesheet"&gt; &lt;/head&gt; &lt;body class="text-center"&gt; &lt;form class="form-signin" action="dashboard.html"&gt; &lt;img class="mb-4" th:src="@&#123;/asserts/img/bootstrap-solid.svg&#125;" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72"&gt; &lt;h1 class="h3 mb-3 font-weight-normal" th:text="#&#123;login.tip&#125;"&gt;Please sign in&lt;/h1&gt; &lt;label class="sr-only" th:text="#&#123;login.username&#125;"&gt;Username&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="Username" th:placeholder="#&#123;login.username&#125;" required="" autofocus=""&gt; &lt;label class="sr-only" th:text="#&#123;login.password&#125;"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" placeholder="Password" th:placeholder="#&#123;login.password&#125;" required=""&gt; &lt;div class="checkbox mb-3"&gt; &lt;label&gt; &lt;input type="checkbox" value="remember-me"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#&#123;login.btn&#125;"&gt;Sign in&lt;/button&gt; &lt;p class="mt-5 mb-3 text-muted"&gt;© 2017-2018&lt;/p&gt; &lt;a class="btn btn-sm"&gt;中文&lt;/a&gt; &lt;a class="btn btn-sm"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = "spring.mvc", name = "locale") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter("l"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split("_"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style="color: red" th:text="$&#123;msg&#125;" th:if="$&#123;not #strings.isEmpty(msg)&#125;"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute("loginUser"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute("msg","没有权限请先登陆"); request.getRequestDispatcher("/index.html").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); registry.addViewController("/main.html").setViewName("dashboard"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**") .excludePathPatterns("/index.html","/","/user/login"); &#125; &#125;; return adapter; &#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—-GET 添加 addEmp?xxx emp—-POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—-PUT 删除 deleteEmp?id=1 emp/{id}—-DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert="~&#123;footer :: copy&#125;"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert="footer :: copy"&gt;&lt;/div&gt;&lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;div th:include="footer :: copy"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 123456789101112131415161718&lt;nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar"&gt; &lt;div class="sidebar-sticky"&gt; &lt;ul class="nav flex-column"&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link active" th:class="$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;" href="#" th:href="@&#123;/main.html&#125;"&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"&gt; &lt;path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"&gt;&lt;/path&gt; &lt;polyline points="9 22 9 12 15 12 15 22"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class="sr-only"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace="commons/bar::#sidebar(activeUri='emps')"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type="email" class="form-control" placeholder="zhangsan@atguigu.com"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—-Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action="@&#123;/emp&#125;" method="post"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name="_method";值就是我们指定的请求方式--&gt; &lt;input type="hidden" name="_method" value="put" th:if="$&#123;emp!=null&#125;"/&gt; &lt;input type="hidden" name="id" th:if="$&#123;emp!=null&#125;" th:value="$&#123;emp.id&#125;"&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="$&#123;emp!=null&#125;?$&#123;emp.email&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class="form-control" name="department.id"&gt; &lt;option th:selected="$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;" th:value="$&#123;dept.id&#125;" th:each="dept:$&#123;depts&#125;" th:text="$&#123;dept.departmentName&#125;"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary" th:text="$&#123;emp!=null&#125;?'修改':'添加'"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each="emp:$&#123;emps&#125;"&gt; &lt;td th:text="$&#123;emp.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text="$&#123;emp.email&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.gender&#125;==0?'女':'男'"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.department.departmentName&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-sm btn-primary" th:href="@&#123;/emp/&#125;+$&#123;emp.id&#125;"&gt;编辑&lt;/a&gt; &lt;button th:attr="del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;" class="btn btn-sm btn-danger deleteBtn"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(".deleteBtn").click(function()&#123; //删除当前员工的 $("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put("timestamp", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView("error", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value("$&#123;error.path:/error&#125;")private String path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = "error/" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("code","user.notexist"); map.put("message",e.getMessage()); return map; &#125;&#125;//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute("javax.servlet.error.status_code"); */ request.setAttribute("javax.servlet.error.status_code",500); map.put("code","user.notexist"); map.put("message",e.getMessage()); //转发到/error return "forward:/error"; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put("company","atguigu"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125; 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),"/myServlet"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir("tomcat")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 5）、嵌入式Servlet容器启动原理；什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—-应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
</search>
